// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`mcp tests > should respond to mcp list_tools call 1`] = `
{
  "tools": [
    {
      "description": "Scans a given local repository for security vulnerabilities and returns auto-generated code fixes.

When to invoke:
• Use when the user explicitly asks to "scan for vulnerabilities", "run a security check", or "test for security issues" in a local repository.
• The repository must exist on disk; supply its absolute path with the required "path" argument.
• Ideal after the user makes code changes (added/modified/staged files) but before committing, or whenever they request a full rescan.

How to invoke:
• Required argument:
  – path (string): absolute path to the repository root.
• Optional arguments:
  – offset (number): pagination offset used when the result set is large.
  – limit (number): maximum number of fixes to include in the response.
  – maxFiles (number): maximum number of files to scan (default: 10). Provide this value to increase the scope of the scan.
  – rescan (boolean): true to force a complete rescan even if cached results exist.

Behaviour:
• If the directory is a valid Git repository, the tool scans the changed files in the repository. If there are no changes, it scans the files included in the las commit.
• If the directory is not a valid Git repository, the tool falls back to scanning recently changed files in the folder.
• If maxFiles is provided, the tool scans the maxFiles most recently changed files in the repository.
• By default, only new, modified, or staged files are scanned; if none are found, it checks recently changed files.
• The tool NEVER commits or pushes changes; it only returns proposed diffs/fixes as text.

Return value:
The response is an object with a single "content" array containing one text element. The text is either:
• A human-readable summary of the fixes / patches, or
• A diagnostic or error message if the scan fails or finds nothing to fix.

Example payload:
{
  "path": "/home/user/my-project",
  "limit": 20,
  "maxFiles": 50,
  "rescan": false
}",
      "display_name": "Scan and Fix Vulnerabilities",
      "inputSchema": {
        "properties": {
          "limit": {
            "description": "[Optional] maximum number of results to return",
            "type": "number",
          },
          "maxFiles": {
            "description": "[Optional] maximum number of files to scan (default: 10). Use higher values for more comprehensive scans or lower values for faster performance.",
            "type": "number",
          },
          "offset": {
            "description": "[Optional] offset for pagination",
            "type": "number",
          },
          "path": {
            "description": "Full local path to repository to scan and fix vulnerabilities",
            "type": "string",
          },
          "rescan": {
            "description": "[Optional] whether to rescan the repository",
            "type": "boolean",
          },
          "scanRecentlyChangedFiles": {
            "description": "[Optional] whether to automatically scan recently changed files when no changed files are found in git status. If false, the tool will prompt the user instead.",
            "type": "boolean",
          },
        },
        "required": [
          "path",
        ],
        "type": "object",
      },
      "name": "scan_and_fix_vulnerabilities",
    },
    {
      "description": "Check the MOBB backend for pre-generated fixes (patch sets) that correspond to vulnerabilities detected in the supplied Git repository.

Use when:
• You already have a local clone of a Git repository and want to know if MOBB has fixes available for it.
• A vulnerability scan has been run previously and uploaded to the MOBB backend and you want to fetch the list or count of ready-to-apply fixes before triggering a full scan-and-fix flow.

Required argument:
• path – absolute path to the local Git repository clone.

Optional arguments:
• offset – pagination offset (integer).
• limit  – maximum number of fixes to return (integer).
• fileFilter – list of file paths relative to the path parameter to filter fixes by. Only fixes affecting these files will be returned. INCOMPATIBLE with fetchFixesFromAnyFile.
• fetchFixesFromAnyFile – if true, fetches fixes for all files in the repository. If false or not set (default), filters fixes to only those affecting files with changes in git status. INCOMPATIBLE with fileFilter.

The tool will:
1. Validate that the provided path is secure and exists.
2. Verify that the directory is a valid Git repository with an "origin" remote.
3. Apply file filtering based on parameters (see below).
4. Query the MOBB service by the origin remote URL and return a textual summary of available fixes (total and by severity) or a message if none are found.

File Filtering Behavior:
• If fetchFixesFromAnyFile is true: Returns fixes for all files (no filtering).
• If fileFilter is provided: Returns only fixes affecting the specified files.
• If neither is provided (default): Returns only fixes affecting files with changes in git status.
• If BOTH are provided: Returns an error (parameters are mutually exclusive).

Call this tool instead of scan_and_fix_vulnerabilities when you only need a fixes summary and do NOT want to perform scanning or code modifications.",
      "display_name": "Fetch Available Fixes",
      "inputSchema": {
        "properties": {
          "fetchFixesFromAnyFile": {
            "description": "[Optional] if true, fetches fixes for all files in the repository. If false or not set, filters fixes to only those affecting files with changes in git status. INCOMPATIBLE with fileFilter",
            "type": "boolean",
          },
          "fileFilter": {
            "description": "[Optional] list of file paths relative to the path parameter to filter fixes by. Only fixes affecting these files will be returned. INCOMPATIBLE with fetchFixesFromAnyFile",
            "items": {
              "type": "string",
            },
            "type": "array",
          },
          "limit": {
            "description": "[Optional] maximum number of results to return",
            "type": "number",
          },
          "offset": {
            "description": "[Optional] offset for pagination",
            "type": "number",
          },
          "path": {
            "description": "Full local path to the cloned git repository to check for available fixes",
            "type": "string",
          },
        },
        "required": [
          "path",
        ],
        "type": "object",
      },
      "name": "fetch_available_fixes",
    },
    {
      "description": "Continuesly monitors your code and scans for new security vulnerabilities.

When to invoke:
• ALWAYS call this tool ONCE at the very end of every reasoning / code-generation session (after all code edits, linting, tests, etc.).
• Invoke when the user explicitly asks to "check for new fixes", "look for fresh patches", or similar.
• The repository must exist locally and be a valid Git repo with an 'origin' remote configured.

How to invoke:
• Required argument:
  – path (string): absolute path to the repository root.

Behaviour:
• If auto-fix is enabled: Returns a list of fixes that were automatically applied to your codebase.
• If auto-fix is disabled: Returns a list of fresh fixes available for manual review and application.
• If no fixes are available, it returns a concise message indicating so.
• Results include a human-readable summary with total count and severity breakdown.

Example payload:
{
  "path": "/home/user/my-project"
}",
      "display_name": "Check for New Available Fixes",
      "inputSchema": {
        "properties": {
          "path": {
            "description": "Full local path to the cloned git repository to check for new available fixes",
            "type": "string",
          },
        },
        "required": [
          "path",
        ],
        "type": "object",
      },
      "name": "check_for_new_available_fixes",
    },
  ],
}
`;
