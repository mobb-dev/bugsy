// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`mcp tests > MCP Prompts Integration > get_prompt handler > should handle all prompts with snapshots > get-prompt-check-for-new-vulnerabilities 1`] = `
{
  "description": "Guide for enabling continuous security monitoring to detect new vulnerabilities",
  "messages": [
    {
      "content": {
        "text": "# Continuous Security Monitoring Setup

This workflow sets up ongoing security monitoring to detect new vulnerabilities as code changes.

## Purpose

The \`check_for_new_available_fixes\` tool provides:
- Lightweight background security monitoring
- Detection of newly introduced vulnerabilities
- Periodic checks without heavy scanning overhead
- Notifications when new fixes become available

## When to Use

Call this tool:
‚úì At the end of a coding session
‚úì After completing a series of edits
‚úì After applying security fixes (to verify no new issues)
‚úì Before committing code changes
‚úì As part of a continuous security workflow
‚úì When setting up a project for security monitoring

## Workflow Steps

### Step 1: Determine Repository Path
Get the full local path to the git repository to monitor.

### Step 2: Call check_for_new_available_fixes

Use the tool with minimal parameters:

\`\`\`json
{
  "path": "<repository-path>"
}
\`\`\`

This tool is designed to be lightweight and non-intrusive.

### Step 3: Interpret Results

The tool will return one of several possible outcomes:

#### New Vulnerabilities Detected

If new security issues are found:

1. **Alert the user promptly:**
   "‚ö†Ô∏è New security vulnerabilities detected!"

2. **Provide summary:**
   - Number of new vulnerabilities
   - Severity breakdown
   - Files affected

3. **Recommend immediate action:**
   - For Critical/High: "I recommend reviewing these immediately"
   - For Medium/Low: "These should be addressed when convenient"

4. **Offer next steps:**
   - "Would you like to scan and see the details?"
   - "Should I fetch the available fixes?"
   - Suggest calling \`scan_and_fix_vulnerabilities\` or \`fetch_available_fixes\`

#### No New Vulnerabilities

"‚úì Monitoring active. No new security vulnerabilities detected."

Optional follow-up:
- Confirm monitoring is now enabled
- Mention that checks will continue periodically
- Reassure the user their code remains secure

#### Monitoring Enabled

"‚úì Continuous security monitoring has been enabled for this repository."

Explain what this means:
- Periodic background checks will run
- User will be notified of new vulnerabilities
- No action required from user right now

### Step 4: Handle User Response

**If new vulnerabilities were found:**

Guide the user to take appropriate action:

1. **Immediate threats (Critical/High):**
   - Strongly recommend scanning now
   - Offer to fetch and display fixes
   - Suggest not committing until fixed

2. **Medium priority:**
   - Add to todo list or backlog
   - Schedule time to address
   - Can proceed with current work

3. **Low priority:**
   - Track for future maintenance
   - Can be addressed in next refactoring
   - No immediate action required

**If no issues found:**

- Congratulate the user on maintaining security
- Remind them monitoring will continue
- Suggest they can continue their work confidently

### Step 5: Integration into Workflow

This tool should be called **automatically** in certain scenarios:

1. **End-of-session cleanup:**
   After a user completes a significant amount of work

2. **Post-fix verification:**
   After applying security fixes to ensure no new issues

3. **Pre-commit hook simulation:**
   Before suggesting the user commit their changes

4. **Periodic checks:**
   During long-running IDE sessions (every 15-30 minutes)

## Best Practices

### DO:
‚úì Call this tool frequently and automatically
‚úì Make it part of your regular workflow
‚úì Alert users immediately when issues are found
‚úì Provide clear severity context
‚úì Offer actionable next steps
‚úì Keep the messaging positive and non-alarming

### DON'T:
‚úó Make this tool intrusive or annoying
‚úó Overwhelm users with constant notifications
‚úó Ignore Critical/High severity findings
‚úó Forget to explain what monitoring means
‚úó Skip this step at the end of sessions

## Monitoring vs. Scanning

It's important to understand the difference:

| Feature | check_for_new_available_fixes | scan_and_fix_vulnerabilities |
|---------|------------------------------|------------------------------|
| Purpose | Continuous monitoring | Full security scan |
| Speed | Very fast | Slower (minutes) |
| Depth | Lightweight check | Comprehensive analysis |
| When | Frequently, automatically | On-demand, deliberately |
| Results | Binary (new issues yes/no) | Detailed vulnerability reports |
| Resource usage | Minimal | Higher |

**Strategy:** Use monitoring frequently, trigger full scans only when needed.

## Example Usage

### Scenario 1: End of Coding Session

\`\`\`
AI: "I'm running a final security check on your changes..."

[Calls check_for_new_available_fixes]

AI: "‚úì All clear! No new security vulnerabilities detected. Your code is safe to commit."
\`\`\`

### Scenario 2: New Vulnerabilities Found

\`\`\`
AI: "Running continuous security monitoring..."

[Calls check_for_new_available_fixes]

AI: "‚ö†Ô∏è I detected 2 new security vulnerabilities:
- 1 High severity
- 1 Medium severity

Would you like me to run a full scan to see the details and available fixes?"

User: "Yes, please"

[AI proceeds to call scan_and_fix_vulnerabilities]
\`\`\`

### Scenario 3: After Applying Fixes

\`\`\`
AI: "I've applied the security fixes. Let me verify no new issues were introduced..."

[Calls check_for_new_available_fixes]

AI: "‚úì Perfect! The fixes resolved the issues and no new vulnerabilities were introduced. Your code is now more secure."
\`\`\`

## Silent vs. Announced Monitoring

**Silent monitoring** (recommended for background checks):
- Call the tool without announcing it
- Only notify user if issues are found
- Keeps the experience smooth and non-intrusive

**Announced monitoring** (use when setting up or after significant changes):
- Tell the user monitoring is running
- Confirm when monitoring is enabled
- Provides transparency and confidence

## Technical Details

The tool:
- Connects to Mobb's backend API
- Checks for new vulnerability data
- Compares against last known state
- Returns summary of new findings
- Maintains minimal overhead

## Ready to Monitor

Call the \`check_for_new_available_fixes\` tool now to enable continuous security monitoring. This is a best practice that helps catch vulnerabilities early and maintain code security over time.
",
        "type": "text",
      },
      "role": "user",
    },
  ],
}
`;

exports[`mcp tests > MCP Prompts Integration > get_prompt handler > should handle all prompts with snapshots > get-prompt-full-security-audit 1`] = `
{
  "description": "Complete end-to-end security audit workflow: scan ‚Üí review ‚Üí fix ‚Üí verify ‚Üí monitor",
  "messages": [
    {
      "content": {
        "text": "# Complete Security Audit Workflow

This is a comprehensive, end-to-end security audit process that will scan, review, fix, verify, and set up monitoring for a repository.

## Audit Overview

This workflow includes:
1. **Initial Assessment** - Understand the repository
2. **Comprehensive Scan** - Full security analysis
3. **Issue Review** - Categorize and prioritize vulnerabilities
4. **Fix Application** - Apply security patches systematically
5. **Verification** - Confirm fixes work correctly
6. **Continuous Monitoring** - Set up ongoing security checks
7. **Final Report** - Document all actions taken

**Estimated Time:** 10-30 minutes depending on repository size and issue count

## Prerequisites

Before starting:
- Repository should be in a clean git state (or user is aware of uncommitted changes)
- Tests should be available and passing
- User has time to review and address issues
- Backup or branch created (recommended for first-time users)

## Phase 1: Initial Assessment

### Step 1.1: Gather Repository Information
- Request repository path from user
- Ask: "What is the full path to the repository you want to audit?"

### Step 1.2: Set Expectations

Inform the user:

\`\`\`
"I'll perform a complete security audit of your repository. This will:
- Scan all code for security vulnerabilities
- Identify issues across all severity levels
- Provide automatic fixes where possible
- Set up continuous monitoring

This process will take a few minutes. I'll guide you through each step and explain my findings.

Ready to begin?"
\`\`\`

### Step 1.3: Check Repository Status

Recommend running git status:
\`\`\`bash
git status
\`\`\`

If there are uncommitted changes, suggest:
- "I see uncommitted changes. Would you like to commit or stash them first?"
- "We can proceed, but I recommend committing current work first."

## Phase 2: Comprehensive Scan

### Step 2.1: Initial Full Scan

Call \`scan_and_fix_vulnerabilities\`:

\`\`\`json
{
  "path": "<repository-path>",
  "limit": 10,
  "maxFiles": 50
}
\`\`\`

Larger limits for comprehensive audit.

### Step 2.2: Initial Results Analysis

When results arrive, analyze and present:

1. **Executive Summary:**
   \`\`\`
   Security Scan Complete
   ----------------------
   Total Vulnerabilities Found: [N]

   By Severity:
   - üî¥ Critical: [N] (immediate action required)
   - üü† High: [N] (urgent)
   - üü° Medium: [N] (important)
   - üîµ Low: [N] (maintenance)

   By Category:
   - [List top 3-5 vulnerability types found]

   Fixable: [N] vulnerabilities have automatic fixes available
   \`\`\`

2. **Initial Recommendation:**
   Based on findings, recommend:
   - If Critical exists: "Address critical issues immediately"
   - If mostly High/Medium: "Systematic fix approach recommended"
   - If only Low: "Good security posture, minor improvements available"

## Phase 3: Issue Review & Prioritization

### Step 3.1: Detailed Issue Presentation

Present issues in priority order:

**For each Critical vulnerability:**
\`\`\`
üî¥ CRITICAL: [Type]
Location: [file:line]
Risk Level: Severe Security Threat

Description: [What the vulnerability is]
Attack Vector: [How it could be exploited]
Impact: [What an attacker could do]

Proposed Fix: [Summary of the fix]
[Show diff/patch preview]

Last modified by: [git blame]
\`\`\`

Continue for High, Medium, Low...

### Step 3.2: Create Fix Plan

Generate a structured fix plan:

\`\`\`markdown
## Security Fix Plan

### Phase 1: Critical Fixes (Do First)
1. [Vulnerability type] in [file]
2. [Vulnerability type] in [file]
...

### Phase 2: High Severity Fixes
1. [Vulnerability type] in [file]
2. [Vulnerability type] in [file]
...

### Phase 3: Medium Severity Fixes
[Can be done in follow-up session]

### Phase 4: Low Severity Fixes
[Add to maintenance backlog]
\`\`\`

### Step 3.3: Get User Approval

Ask user how they want to proceed:

"I've identified the security issues and created a fix plan. How would you like to proceed?

1. **Comprehensive Fix** - Fix all Critical and High issues now (recommended)
2. **Critical Only** - Fix only Critical issues now
3. **Selective Fix** - Review and choose which fixes to apply
4. **Report Only** - Generate report without applying fixes (for review)

Recommendation: Option 1 for best security posture."

## Phase 4: Fix Application

Based on user choice, systematically apply fixes:

### Step 4.1: Apply Critical Fixes

For each Critical fix:
1. Show what will be fixed
2. Apply the patch
3. Confirm application: "‚úì Fixed: [vulnerability] in [file]"
4. Track progress: "[N/Total] Critical fixes applied"

### Step 4.2: Apply High Severity Fixes

Same process as Critical, but can be done in batches.

### Step 4.3: Handle Fix Failures

If a fix fails to apply:
1. Note the failure
2. Show the conflict or error
3. Mark for manual review
4. Continue with remaining fixes
5. Summarize failed fixes at the end

## Phase 5: Verification

### Step 5.1: Verify Patches Applied

Check each modified file:
\`\`\`bash
git status
git diff
\`\`\`

Confirm:
- Expected files were modified
- No unexpected changes
- No merge conflicts

### Step 5.2: Run Test Suite

If tests exist:

\`\`\`bash
# Run appropriate test command
npm test
# or
pytest
# or
mvn test
\`\`\`

**If tests pass:**
"‚úÖ All tests passed! Security fixes did not break functionality."

**If tests fail:**
"‚ö†Ô∏è Some tests are failing after applying fixes:
[List failing tests]

This could mean:
1. Tests need to be updated (common for security fixes)
2. A fix introduced an issue (less common)

Would you like me to:
1. Review the failing tests
2. Revert specific fixes
3. Continue anyway (tests may need updates)"

### Step 5.3: Re-scan for Verification

Call \`scan_and_fix_vulnerabilities\` again with \`rescan: true\`:

\`\`\`json
{
  "path": "<repository-path>",
  "rescan": true,
  "limit": 10
}
\`\`\`

Compare before/after:
- Confirm fixed vulnerabilities are gone
- Check no new vulnerabilities were introduced
- Verify severity counts decreased as expected

## Phase 6: Continuous Monitoring Setup

### Step 6.1: Enable Monitoring

Call \`check_for_new_available_fixes\`:

\`\`\`json
{
  "path": "<repository-path>"
}
\`\`\`

### Step 6.2: Explain Monitoring

"‚úÖ Continuous security monitoring is now enabled for this repository.

What this means:
- Periodic background checks for new vulnerabilities
- Notifications when security issues are detected
- Ongoing protection as code evolves

This helps maintain the security improvements we just made."

## Phase 7: Final Report

### Step 7.1: Generate Comprehensive Report

Create a detailed report:

\`\`\`markdown
# Security Audit Report
Repository: [name/path]
Date: [date]
Audited by: Mobb AI Security Assistant

## Executive Summary
- Total vulnerabilities found: [N]
- Vulnerabilities fixed: [N]
- Files modified: [N]
- Test status: [Pass/Fail/Not Run]

## Vulnerabilities Fixed

### Critical (üî¥)
1. [Type] in [file:line] - FIXED ‚úÖ
   - Risk: [description]
   - Fix: [description]

2. [Type] in [file:line] - FIXED ‚úÖ
   ...

### High (üü†)
[Similar format]

### Medium (üü°)
[List - note which were fixed]

### Low (üîµ)
[List - note which were fixed]

## Files Modified
- [list all modified files with change descriptions]

## Verification Results
‚úÖ All fixes applied successfully
‚úÖ Tests passing
‚úÖ Re-scan confirms vulnerabilities resolved
‚úÖ No new vulnerabilities introduced

## Remaining Items
- [N] Medium severity issues (recommended to fix soon)
- [N] Low severity issues (maintenance backlog)

## Recommendations
1. Commit these security improvements
2. Deploy to staging environment for testing
3. Schedule follow-up for remaining Medium issues
4. Review security practices to prevent future issues
5. Keep continuous monitoring enabled

## Next Steps
1. Review the changes: git diff
2. Run additional tests if needed
3. Commit: git add . && git commit -m "Security fixes: addressed [N] critical and high severity vulnerabilities"
4. Push to remote repository
5. Deploy with confidence

---
üîí Security Level: [Excellent/Good/Fair] (based on remaining issues)
\`\`\`

### Step 7.2: Provide Next Steps

Give clear guidance:

"## What to do next:

**Immediate (Do now):**
1. Review the changes made (git diff)
2. Commit the security fixes
3. Push to your repository

**Soon (This week):**
1. Address remaining Medium severity issues ([N] items)
2. Review security best practices for your framework
3. Share this report with your team

**Ongoing:**
1. Continuous monitoring is active
2. Run security scans after major changes
3. Keep dependencies updated

**Questions?**
- Need help with any specific fix?
- Want to understand a vulnerability better?
- Need guidance on preventing similar issues?

Ask me anything!"

## Important Guidelines

### Communication Throughout

**Be:**
- Professional and clear
- Patient and thorough
- Encouraging and supportive
- Transparent about what you're doing

**Tone:**
- Security issues are serious but fixable
- Congratulate progress
- Celebrate improvements
- Don't blame or shame

### DO:
‚úÖ Follow all phases systematically
‚úÖ Explain each step clearly
‚úÖ Get user approval before major actions
‚úÖ Verify all changes
‚úÖ Provide comprehensive documentation
‚úÖ Enable monitoring
‚úÖ Give clear next steps

### DON'T:
‚ùå Rush through the process
‚ùå Skip verification steps
‚ùå Apply fixes without explanation
‚ùå Forget to check for new issues
‚ùå Leave user without next steps
‚ùå Create alarm - be solution-focused

## Time Management

For large repositories with many issues:
- Take breaks between phases
- Offer to pause and resume later
- Batch fixes appropriately
- Don't overwhelm the user

Suggest: "We've fixed [N] critical issues. Would you like to continue with High severity, or take a break and resume later?"

## Success Criteria

Audit is successful when:
‚úÖ All Critical vulnerabilities are fixed
‚úÖ Most High severity issues addressed
‚úÖ All fixes verified and tested
‚úÖ No new vulnerabilities introduced
‚úÖ Continuous monitoring enabled
‚úÖ Comprehensive report provided
‚úÖ User understands next steps

## Ready to Begin

This is a comprehensive security audit that will significantly improve the security posture of the repository. Follow each phase carefully, communicate clearly, and celebrate the improvements made.

Begin the audit now.
",
        "type": "text",
      },
      "role": "user",
    },
  ],
}
`;

exports[`mcp tests > MCP Prompts Integration > get_prompt handler > should handle all prompts with snapshots > get-prompt-review-and-fix-critical 1`] = `
{
  "description": "Focused workflow for identifying and fixing Critical and High severity security vulnerabilities",
  "messages": [
    {
      "content": {
        "text": "# Critical Security Vulnerabilities - Review and Fix

This is a focused workflow for identifying and addressing Critical and High severity security vulnerabilities that require immediate attention.

## Workflow Purpose

Use this workflow when:
- Security is a high priority
- Preparing for production deployment
- Security audit or compliance review is needed
- You want to address the most severe issues first
- Time is limited and you need to focus on critical threats

## Severity Priority

**CRITICAL** üî¥
- Immediate security risk
- Can lead to complete system compromise
- Examples: Remote Code Execution, Authentication Bypass, SQL Injection with data exposure
- **Action: FIX IMMEDIATELY**

**HIGH** üü†
- Significant security vulnerability
- Can lead to data breaches or unauthorized access
- Examples: XSS attacks, Privilege Escalation, Exposed Sensitive Data
- **Action: FIX URGENTLY**

Medium and Low severity issues will be noted but not prioritized in this workflow.

## Workflow Steps

### Step 1: Initial Scan
Obtain the repository path from the user.

Call \`scan_and_fix_vulnerabilities\`:

\`\`\`json
{
  "path": "<repository-path>",
  "limit": 10,
  "maxFiles": 20
}
\`\`\`

Higher limits to ensure we catch all critical issues.

### Step 2: Filter and Present Critical Issues

When results arrive:

1. **Count vulnerabilities by severity:**
   - Critical count
   - High count
   - Medium count (mention but don't focus)
   - Low count (mention but don't focus)

2. **Present ONLY Critical and High severity issues:**

   For each Critical/High vulnerability:

   \`\`\`
   üî¥ CRITICAL: [Vulnerability Type]

   File: [path/to/file.ext:line]
   Last modified by: [git blame user]

   Risk: [Explain the security risk in simple terms]

   Proposed Fix:
   [Show the diff/patch]

   Impact: [What this fix does and why it's necessary]
   \`\`\`

3. **Provide clear summary:**
   "Found X critical and Y high severity vulnerabilities that require immediate attention."

### Step 3: Prioritize Fixes

Create a fix priority list:

**Phase 1 - Critical (DO FIRST):**
- List all Critical issues
- Sort by risk level
- Recommend fixing ALL before any High issues

**Phase 2 - High (DO SECOND):**
- List all High issues
- Can be addressed after Critical are resolved

**Ask the user:**
"I recommend we fix these in priority order. Would you like me to:
1. Apply ALL critical fixes automatically (recommended)
2. Review each critical fix individually
3. See the full details before proceeding"

### Step 4: Apply Fixes

Based on user choice:

#### Option 1: Apply All Critical Automatically

\`\`\`
"I'll apply all [N] critical fixes now. This will modify [X] files."

For each fix:
1. Apply the patch
2. Verify it applied successfully
3. Show brief confirmation: "‚úì Fixed: [vulnerability type] in [file]"

"All critical fixes applied. Running verification..."
[Call check_for_new_available_fixes to verify]

"Next, I can address the [N] high severity issues. Continue?"
\`\`\`

#### Option 2: Review Each Fix Individually

For each Critical fix:
1. Show the vulnerability details
2. Show the exact code changes
3. Explain the security improvement
4. Ask: "Apply this fix? (yes/no/skip)"
5. Apply if approved
6. Move to next

#### Option 3: Provide Full Details First

- Show comprehensive analysis of each vulnerability
- Include CVE references if available
- Explain attack vectors
- Demonstrate how the fix prevents the attack
- Then proceed to fixing phase

### Step 5: Verification

After applying fixes:

1. **Verify fixes applied correctly:**
   - Check files were modified
   - No merge conflicts
   - Code syntax is valid

2. **Run tests if available:**
   \`\`\`bash
   npm test
   # or
   pytest
   # or appropriate test command
   \`\`\`

3. **Re-scan to confirm:**
   Call \`scan_and_fix_vulnerabilities\` again with \`rescan: true\`

   Verify:
   - Critical issues are resolved
   - No new issues were introduced
   - High severity count decreased (if those were also fixed)

### Step 6: Summary Report

Provide a comprehensive summary:

\`\`\`markdown
## Security Fix Summary

### Fixed
- ‚úÖ [N] Critical vulnerabilities resolved
- ‚úÖ [N] High severity vulnerabilities resolved

### Files Modified
- [list of modified files]

### Remaining Issues
- ‚ö†Ô∏è [N] Medium severity (can be addressed later)
- ‚ÑπÔ∏è [N] Low severity (maintenance backlog)

### Recommendations
1. Run your test suite to ensure functionality
2. Review the changes before committing
3. Consider addressing remaining High severity issues
4. Schedule time for Medium/Low issues
5. Enable continuous monitoring

### Next Steps
- Commit these security fixes
- Deploy to staging for testing
- Schedule follow-up for remaining issues
\`\`\`

## Important Guidelines

### Communication Style

**For Critical Issues:**
- Use urgent but calm language
- Clearly explain the risk
- Don't create panic, but convey seriousness
- Be direct about the need to fix immediately

**For High Issues:**
- Emphasize importance but not emergency
- Explain impact on security posture
- Recommend fixing soon but not necessarily right now

### DO:
‚úÖ Fix ALL Critical issues before moving to High
‚úÖ Explain each vulnerability clearly
‚úÖ Show exact code changes
‚úÖ Verify fixes were applied successfully
‚úÖ Run tests after applying fixes
‚úÖ Create a clear summary of actions taken
‚úÖ Recommend continuous monitoring

### DON'T:
‚ùå Apply fixes without user approval (except if explicitly requested)
‚ùå Minimize the importance of Critical issues
‚ùå Get distracted by Medium/Low issues during this workflow
‚ùå Skip verification steps
‚ùå Forget to check for new issues after applying fixes
‚ùå Rush through explanations

## Example Interaction

\`\`\`
AI: "Scanning repository for critical security vulnerabilities..."

[Scans]

AI: "‚ö†Ô∏è **Security Alert: Critical Issues Found**

I found 3 critical and 5 high severity vulnerabilities:

üî¥ **CRITICAL ISSUES** (Must fix immediately):

1. **SQL Injection** in src/api/users.ts:67
   - Risk: Attacker can access entire database
   - Last modified by: john@example.com
   - Fix: Use parameterized queries

2. **Authentication Bypass** in src/auth/middleware.ts:23
   - Risk: Unauthorized access to admin functions
   - Last modified by: jane@example.com
   - Fix: Validate JWT signature properly

3. **Remote Code Execution** in src/utils/processor.ts:45
   - Risk: Attacker can execute arbitrary code on server
   - Last modified by: bob@example.com
   - Fix: Sanitize eval() input

üü† **HIGH SEVERITY** (Fix urgently):
[Lists 5 high issues...]

**Recommendation:** Fix all 3 critical issues immediately. Would you like me to:
1. Apply ALL critical fixes now (recommended) ‚Üê [DEFAULT]
2. Review each fix individually
3. See detailed analysis first"

User: "Apply all critical fixes"

AI: "Applying all critical fixes...

‚úì Fixed: SQL Injection in src/api/users.ts
‚úì Fixed: Authentication Bypass in src/auth/middleware.ts
‚úì Fixed: Remote Code Execution in src/utils/processor.ts

All critical vulnerabilities resolved! Running verification...

‚úì Verification complete - no new issues introduced.

3 files modified, 0 critical issues remaining.

Would you like to proceed with fixing the 5 high severity issues?"
\`\`\`

## Ready to Begin

This workflow focuses exclusively on the most dangerous vulnerabilities. Follow the steps above to systematically eliminate critical security threats from the codebase.

Start by scanning the repository and prioritizing Critical and High severity issues.
",
        "type": "text",
      },
      "role": "user",
    },
  ],
}
`;

exports[`mcp tests > MCP Prompts Integration > get_prompt handler > should handle all prompts with snapshots > get-prompt-scan-recent-changes 1`] = `
{
  "description": "Guide for scanning only recently modified files for new security vulnerabilities",
  "messages": [
    {
      "content": {
        "text": "# Scan Recent Changes for Security Issues

This workflow helps you quickly scan only the files that have been recently modified, making security checks fast and targeted.

## When to Use This Workflow

Use this approach when:
- You've just made code changes and want to check for new vulnerabilities
- You want a quick security check without scanning the entire repository
- You're working in a specific area of the codebase
- You want faster scan results
- You're doing iterative development and want continuous security feedback

## Workflow Steps

### Step 1: Determine Repository Path
Ask the user for the full local path to the git repository.

### Step 2: Call scan_and_fix_vulnerabilities with Recent Changes Flag

Use the \`scan_and_fix_vulnerabilities\` tool with the \`scanRecentlyChangedFiles\` parameter:

\`\`\`json
{
  "path": "<repository-path>",
  "scanRecentlyChangedFiles": true,
  "limit": 5
}
\`\`\`

**Key parameters:**
- \`scanRecentlyChangedFiles: true\` - Only scans files modified recently
- \`limit: 5\` - Return up to 5 fixes (adjustable based on user needs)

### Step 3: Present Results

When you receive results:

#### If new vulnerabilities found:

1. **Alert the user:**
   "‚ö†Ô∏è Security issues detected in recently modified files!"

2. **Provide context:**
   - Number of new vulnerabilities introduced
   - Which files are affected
   - Severity breakdown
   - Who made the changes (git blame)

3. **Show each vulnerability:**
   - File and line number
   - Type of vulnerability
   - Severity level
   - Proposed fix with diff preview

4. **Recommend immediate action:**
   For Critical/High severity:
   - "I strongly recommend addressing these issues before committing/merging"
   - "Would you like me to apply the fixes now?"

#### If no vulnerabilities found:

"‚úì Great! No new security issues detected in your recent changes."

Optional suggestions:
- Continue with your work
- Commit your changes
- Consider enabling continuous monitoring

#### If no recently changed files:

"No recently modified files detected. This could mean:
- No uncommitted changes exist
- No files were modified recently
- The repository has no git history

Would you like to:
1. Perform a full repository scan instead?
2. Check the repository status?"

### Step 4: Handle User Decisions

**If user wants to apply fixes:**
- Confirm each fix before applying
- Show the exact changes
- Apply patches sequentially
- Verify each application succeeded
- Run tests if available

**If user wants to see more details:**
- Explain the vulnerability type
- Show the vulnerable code pattern
- Explain how the fix improves security
- Provide references or documentation links

**If user wants to continue without fixing:**
- Warn about the risks (especially for Critical/High)
- Suggest creating an issue to track the vulnerability
- Remind them to fix before merging to production

### Step 5: Post-Scan Recommendations

After handling vulnerabilities:

1. **If fixes were applied:**
   - Verify the code still works (run tests)
   - Review the changes
   - Update commit message to mention security fixes
   - Consider running a full scan to check for other issues

2. **If fixes were deferred:**
   - Create tracking issues for the vulnerabilities
   - Add TODO comments in the code
   - Schedule time to address them

3. **Enable continuous monitoring:**
   Call \`check_for_new_available_fixes\`:
   \`\`\`json
   {
     "path": "<repository-path>"
   }
   \`\`\`

## Advantages of Scanning Recent Changes

‚úì **Fast**: Only scans modified files
‚úì **Targeted**: Focuses on your current work
‚úì **Immediate feedback**: Catch issues before they're committed
‚úì **Less overwhelming**: Smaller result set
‚úì **Continuous security**: Integrates into development workflow

## Important Notes

### DO:
‚úì Run this scan after making changes but before committing
‚úì Address Critical/High severity issues immediately
‚úì Explain security risks clearly to the user
‚úì Offer to apply fixes automatically
‚úì Provide context about what changed and why it's vulnerable

### DON'T:
‚úó Skip Critical/High severity warnings
‚úó Apply fixes without showing the user
‚úó Ignore the vulnerability just because the scan is quick
‚úó Forget to run tests after applying fixes
‚úó Assume all recent changes have vulnerabilities

## Integration with Development Workflow

This scan type integrates well with:
- **Pre-commit hooks**: Scan before each commit
- **IDE integration**: Scan on file save or periodically
- **CI/CD pipelines**: Fast security check in pull requests
- **Iterative development**: Continuous security feedback

## Example Usage

\`\`\`
User: "I just added a new API endpoint for user data. Can you check if it's secure?"

AI: "I'll scan your recent changes for security vulnerabilities..."

[Calls scan_and_fix_vulnerabilities with scanRecentlyChangedFiles: true]

AI: "‚ö†Ô∏è Found 1 security issue in your recent changes:

**SQL Injection Vulnerability** (Critical)
- File: src/api/user-data.ts:34
- Your new endpoint is vulnerable to SQL injection

The issue is in this code:
\`\`\`typescript
const query = \`SELECT * FROM users WHERE id = \${req.params.id}\`
\`\`\`

Recommended fix: Use parameterized queries
\`\`\`typescript
const query = 'SELECT * FROM users WHERE id = $1'
const result = await db.query(query, [req.params.id])
\`\`\`

This is a Critical severity issue. I strongly recommend fixing it before committing. Would you like me to apply this fix automatically?"
\`\`\`

## Ready to Scan

You now have the guidance needed to perform a fast, targeted security scan of recent changes. Follow the workflow above to help users catch security issues early in their development process.
",
        "type": "text",
      },
      "role": "user",
    },
  ],
}
`;

exports[`mcp tests > MCP Prompts Integration > get_prompt handler > should handle all prompts with snapshots > get-prompt-scan-repository 1`] = `
{
  "description": "Guide for performing an initial security scan of a repository using Mobb tools",
  "messages": [
    {
      "content": {
        "text": "# Security Repository Scan Workflow

You are about to perform a security scan for the current repository. Follow this workflow to scan the repository for vulnerabilities and present the findings to the user.

## Workflow Steps

### Step 1: Determine Repository Path
- The user should provide the full local path to the git repository
- Ask: "What is the full path to the repository you want to scan?"
- Example: /Users/username/projects/my-app

### Step 2: Call scan_and_fix_vulnerabilities Tool

Use the \`scan_and_fix_vulnerabilities\` tool with these parameters:

\`\`\`json
{
  "path": "<repository-path>",
  "limit": 3,
  "maxFiles": 10
}
\`\`\`

**Why these defaults?**
- \`limit: 3\` - Start with top 3 most severe vulnerabilities
- \`maxFiles: 10\` - Reasonable initial scan scope

**Optional parameters** (use if user specifies):
- \`rescan: true\` - Force a fresh scan (if user wants to override cached results)
- \`scanRecentlyChangedFiles: true\` - Only scan recently modified files (faster)

### Step 3: Process and Present Results

When you receive the scan results:

#### If vulnerabilities are found:

1. **Provide a summary:**
   - Total number of vulnerabilities found
   - Breakdown by severity (Critical, High, Medium, Low)
   - Number of fixes available

2. **Present the top fixes:**
   - Show each fix with:
     * Severity level
     * Vulnerability type (e.g., "SQL Injection", "XSS", "Insecure Dependency")
     * Affected file(s)
     * Who last modified the vulnerable code (git blame)
     * Brief description from the fix

3. **Show the fix preview:**
   - Display the git diff/patch for each fix
   - Explain what changes will be made
   - Highlight the security improvement

4. **Ask for user preference:**
   - "Would you like to apply these fixes automatically?"
   - "Would you like to see more vulnerabilities?" (if more exist)
   - "Would you like to focus on a specific severity level?"

#### If no vulnerabilities are found:

Congratulate the user! Their repository appears to be secure. Suggest:
- Running periodic scans as code changes
- Enabling continuous monitoring with \`check_for_new_available_fixes\`

#### If report is expired:

Inform the user that a previous scan is too old. Ask:
- "A previous scan exists but is outdated. Would you like to run a fresh scan?"
- If yes, call \`scan_and_fix_vulnerabilities\` with \`rescan: true\`

### Step 4: Handle User Actions

Based on user response:

**If user wants to apply fixes:**
- Confirm which fixes to apply (all, or specific ones)
- Apply each fix patch using standard git apply workflow
- Verify the changes
- Run tests if available
- Create a commit with the fixes

**If user wants to see more:**
- Call \`fetch_available_fixes\` with:
  \`\`\`json
  {
    "path": "<repository-path>",
    "offset": 3,
    "limit": 5
  }
  \`\`\`
- Present the additional fixes following the same format

**If user wants to filter by severity:**
- The results are already sorted by severity (Critical ‚Üí High ‚Üí Medium ‚Üí Low)
- Explain the severity of issues found
- Focus on the most critical issues first

### Step 5: Post-Scan Actions

After completing the scan and any fixes:

1. **Summary of actions taken:**
   - Number of fixes applied
   - Remaining vulnerabilities (if any)
   - Files modified

2. **Recommendations:**
   - Run tests to ensure fixes don't break functionality
   - Review the changes before committing
   - Consider addressing remaining Medium/Low severity issues
   - Set up continuous monitoring

3. **Call monitoring tool:**
   Call \`check_for_new_available_fixes\` to enable ongoing security monitoring:
   \`\`\`json
   {
     "path": "<repository-path>"
   }
   \`\`\`

## Important Reminders

### DO:
‚úì Present vulnerabilities clearly with severity context
‚úì Ask for user confirmation before applying fixes
‚úì Explain what each fix does
‚úì Start with critical/high severity issues
‚úì Provide clear next steps
‚úì Mention git blame information (shows responsibility)

### DON'T:
‚úó Apply fixes automatically without user approval
‚úó Overwhelm user with all vulnerabilities at once
‚úó Skip severity information
‚úó Forget to call monitoring tool at the end
‚úó Assume the user wants to fix everything immediately

## Error Handling

- **Authentication error**: Guide user to authenticate with Mobb
- **Path not found**: Verify the path is correct and is a git repository
- **Scan timeout**: Suggest scanning fewer files or recent changes only
- **No report found**: This is expected for first-time scans, proceed normally

## Example Conversation Flow

\`\`\`
AI: "I'll scan your repository for security vulnerabilities. This may take a moment..."

[Calls scan_and_fix_vulnerabilities]

AI: "Scan complete! I found 12 security vulnerabilities:
- 2 Critical severity
- 5 High severity
- 4 Medium severity
- 1 Low severity

Here are the top 3 most critical issues:

1. **SQL Injection** (Critical)
   - File: src/database/users.ts:45
   - Last modified by: john@example.com
   - Fix: Parameterize SQL query to prevent injection

   [Shows diff preview]

2. **Cross-Site Scripting (XSS)** (Critical)
   - File: src/components/UserProfile.tsx:122
   - Last modified by: jane@example.com
   - Fix: Sanitize user input before rendering

   [Shows diff preview]

3. **Insecure Dependency** (High)
   - Package: lodash@4.17.15
   - Fix: Upgrade to lodash@4.17.21 (fixes CVE-2021-23337)

Would you like to:
1. Apply these fixes automatically
2. See more vulnerabilities
3. Focus on specific issues"
\`\`\`

## Ready to Begin

You now have all the information needed to perform a security scan. Follow the steps above, call the appropriate tools, and guide the user through the process professionally and clearly.
",
        "type": "text",
      },
      "role": "user",
    },
  ],
}
`;

exports[`mcp tests > MCP Prompts Integration > get_prompt handler > should handle all prompts with snapshots > get-prompt-security-tools-overview 1`] = `
{
  "description": "Provides an overview of available Mobb security tools and guidance on when to use each tool",
  "messages": [
    {
      "content": {
        "text": "# Mobb Security Tools Overview

You have access to powerful security scanning and auto-fixing tools from Mobb. Here's a comprehensive guide to the available tools and when to use them:

## Available Tools

### 1. **scan_and_fix_vulnerabilities**
**Purpose:** Scans a local repository for security vulnerabilities and returns automatically-generated fixes.

**When to use:**
- First-time security scan of a repository
- Comprehensive security audit needed
- User explicitly requests a security scan
- After major code changes or refactoring

**Key features:**
- Scans the entire repository or specific files
- Identifies vulnerabilities across multiple categories (XSS, SQL injection, insecure dependencies, etc.)
- Provides detailed fix information including severity levels
- Returns git-compatible patches that can be directly applied
- Shows who last modified vulnerable code (git blame integration)

**Parameters:**
- \`path\` (required): Full local path to the git repository
- \`offset\`: Pagination offset for results (default: 0)
- \`limit\`: Number of fixes to return (default: 3)
- \`maxFiles\`: Maximum files to scan (default: 10)
- \`rescan\`: Force a new scan even if recent report exists
- \`scanRecentlyChangedFiles\`: Only scan recently modified files

**Important notes:**
- This tool requires authentication
- Scans may take time for large repositories
- Results are cached - use \`rescan: true\` to force a fresh scan
- The tool returns fixes in order of severity (Critical ‚Üí High ‚Üí Medium ‚Üí Low)

### 2. **fetch_available_fixes**
**Purpose:** Retrieves pre-generated fixes from previous scans without triggering a new scan.

**When to use:**
- Checking for existing fixes without scanning
- Retrieving additional fixes from a paginated result set
- User wants to see more fixes beyond the initial set
- Fetching fixes for specific files

**Key features:**
- Fast retrieval of existing fix data
- No scanning overhead
- Supports file filtering
- Pagination for large result sets

**Parameters:**
- \`path\` (required): Full local path to the git repository
- \`offset\`: Pagination offset
- \`limit\`: Number of fixes to return
- \`fileFilter\`: Filter by specific file path
- \`fetchFixesFromAnyFile\`: Fetch fixes across all files

**Important notes:**
- Returns an error if no previous scan exists
- Does NOT trigger a new scan
- Use this when you want to avoid re-scanning

### 3. **check_for_new_available_fixes**
**Purpose:** Monitors code for new security vulnerabilities and notifies when fixes are available.

**When to use:**
- Continuous security monitoring
- After completing a series of edits
- End of a coding session
- User requests ongoing security checks

**Key features:**
- Lightweight background checking
- Detects new vulnerabilities introduced by code changes
- Non-intrusive monitoring

**Parameters:**
- \`path\` (required): Full local path to the git repository

**Important notes:**
- This is typically called automatically at the end of operations
- Much lighter weight than full scans
- Part of Mobb's continuous monitoring workflow

## Best Practices

### Tool Selection Guidelines

1. **Starting fresh?** ‚Üí Use \`scan_and_fix_vulnerabilities\`
2. **Already scanned, need more results?** ‚Üí Use \`fetch_available_fixes\`
3. **Continuous monitoring?** ‚Üí Use \`check_for_new_available_fixes\`

### User Interaction Patterns

**When to ask for user confirmation:**
- Before applying fixes automatically
- Before running a full repository scan (can be time-consuming)
- Before re-scanning when a recent scan exists
- When multiple high-severity issues are found

**When to proceed automatically:**
- Fetching additional fixes from existing scans
- Running background monitoring checks
- Displaying vulnerability information
- Showing fix previews

### Severity Levels

Vulnerabilities are categorized by severity:
- **CRITICAL**: Immediate action required - severe security risk
- **HIGH**: Important security issue - should be fixed soon
- **MEDIUM**: Moderate security concern - fix when feasible
- **LOW**: Minor security issue - fix during regular maintenance

**Recommended approach:**
1. Address CRITICAL issues immediately
2. Review and fix HIGH severity issues
3. Plan fixes for MEDIUM issues
4. Address LOW issues during regular maintenance

### Workflow Example

\`\`\`
1. User opens a repository
2. Call scan_and_fix_vulnerabilities with default parameters
3. Review the returned fixes (typically top 3 by severity)
4. Present fixes to user with severity breakdown
5. If user wants to see more: call fetch_available_fixes with appropriate offset
6. When user approves fixes: apply the patches using git apply
7. After session: call check_for_new_available_fixes for monitoring
\`\`\`

## Authentication

All tools require authentication via the Mobb API. The tools will handle authentication automatically and prompt if credentials are needed.

## Error Handling

Common scenarios:
- **No fixes found**: Repository has no vulnerabilities or they're not fixable
- **Report expired**: Previous scan is too old, need to rescan
- **No report found**: No previous scan exists, run scan_and_fix_vulnerabilities
- **Authentication required**: User needs to authenticate with Mobb

## Next Steps

To get started with scanning a repository, use the \`scan-repository\` prompt which will guide you through the scanning workflow.

For a complete security audit workflow, use the \`full-security-audit\` prompt.
",
        "type": "text",
      },
      "role": "user",
    },
  ],
}
`;

exports[`mcp tests > MCP Prompts Integration > list_prompts handler > should match snapshot of list_prompts response > list-prompts-response 1`] = `
{
  "prompts": [
    {
      "arguments": undefined,
      "description": "Provides an overview of available Mobb security tools and guidance on when to use each tool",
      "name": "security-tools-overview",
    },
    {
      "arguments": [
        {
          "description": "Optional: Full local path to the git repository to scan",
          "name": "path",
          "required": false,
        },
      ],
      "description": "Guide for performing an initial security scan of a repository using Mobb tools",
      "name": "scan-repository",
    },
    {
      "arguments": [
        {
          "description": "Optional: Full local path to the git repository to scan",
          "name": "path",
          "required": false,
        },
      ],
      "description": "Guide for scanning only recently modified files for new security vulnerabilities",
      "name": "scan-recent-changes",
    },
    {
      "arguments": [
        {
          "description": "Optional: Full local path to the git repository to monitor",
          "name": "path",
          "required": false,
        },
      ],
      "description": "Guide for enabling continuous security monitoring to detect new vulnerabilities",
      "name": "check-for-new-vulnerabilities",
    },
    {
      "arguments": [
        {
          "description": "Optional: Full local path to the git repository to scan and fix",
          "name": "path",
          "required": false,
        },
      ],
      "description": "Focused workflow for identifying and fixing Critical and High severity security vulnerabilities",
      "name": "review-and-fix-critical",
    },
    {
      "arguments": [
        {
          "description": "Optional: Full local path to the git repository to audit",
          "name": "path",
          "required": false,
        },
      ],
      "description": "Complete end-to-end security audit workflow: scan ‚Üí review ‚Üí fix ‚Üí verify ‚Üí monitor",
      "name": "full-security-audit",
    },
  ],
}
`;

exports[`mcp tests > should respond to mcp list_tools call 1`] = `
{
  "tools": [
    {
      "description": "Scans a given local repository for security vulnerabilities and returns auto-generated code fixes.

When to invoke:
‚Ä¢ Use when the user explicitly asks to "scan for vulnerabilities", "run a security check", or "test for security issues" in a local repository.
‚Ä¢ The repository must exist on disk; supply its absolute path with the required "path" argument.
‚Ä¢ Ideal after the user makes code changes (added/modified/staged files) but before committing, or whenever they request a full rescan.

How to invoke:
‚Ä¢ Required argument:
  ‚Äì path (string): absolute path to the repository root.
‚Ä¢ Optional arguments:
  ‚Äì offset (number): pagination offset used when the result set is large.
  ‚Äì limit (number): maximum number of fixes to include in the response.
  ‚Äì maxFiles (number): maximum number of files to scan (default: 10). Provide this value to increase the scope of the scan.
  ‚Äì rescan (boolean): true to force a complete rescan even if cached results exist.

Behaviour:
‚Ä¢ If the directory is a valid Git repository, the tool scans the changed files in the repository. If there are no changes, it scans the files included in the las commit.
‚Ä¢ If the directory is not a valid Git repository, the tool falls back to scanning recently changed files in the folder.
‚Ä¢ If maxFiles is provided, the tool scans the maxFiles most recently changed files in the repository.
‚Ä¢ By default, only new, modified, or staged files are scanned; if none are found, it checks recently changed files.
‚Ä¢ The tool NEVER commits or pushes changes; it only returns proposed diffs/fixes as text.

Return value:
The response is an object with a single "content" array containing one text element. The text is either:
‚Ä¢ A human-readable summary of the fixes / patches, or
‚Ä¢ A diagnostic or error message if the scan fails or finds nothing to fix.

Example payload:
{
  "path": "/home/user/my-project",
  "limit": 20,
  "maxFiles": 50,
  "rescan": false
}",
      "inputSchema": {
        "properties": {
          "limit": {
            "description": "[Optional] maximum number of results to return",
            "type": "number",
          },
          "maxFiles": {
            "description": "[Optional] maximum number of files to scan (default: 10). Use higher values for more comprehensive scans or lower values for faster performance.",
            "type": "number",
          },
          "offset": {
            "description": "[Optional] offset for pagination",
            "type": "number",
          },
          "path": {
            "description": "Full local path to repository to scan and fix vulnerabilities",
            "type": "string",
          },
          "rescan": {
            "description": "[Optional] whether to rescan the repository",
            "type": "boolean",
          },
          "scanRecentlyChangedFiles": {
            "description": "[Optional] whether to automatically scan recently changed files when no changed files are found in git status. If false, the tool will prompt the user instead.",
            "type": "boolean",
          },
        },
        "required": [
          "path",
        ],
        "type": "object",
      },
      "name": "scan_and_fix_vulnerabilities",
    },
    {
      "description": "Check the MOBB backend for pre-generated fixes (patch sets) that correspond to vulnerabilities detected in the supplied Git repository.

Use when:
‚Ä¢ You already have a local clone of a Git repository and want to know if MOBB has fixes available for it.
‚Ä¢ A vulnerability scan has been run previously and uploaded to the MOBB backend and you want to fetch the list or count of ready-to-apply fixes before triggering a full scan-and-fix flow.

Required argument:
‚Ä¢ path ‚Äì absolute path to the local Git repository clone.

Optional arguments:
‚Ä¢ offset ‚Äì pagination offset (integer).
‚Ä¢ limit  ‚Äì maximum number of fixes to return (integer).
‚Ä¢ fileFilter ‚Äì list of file paths relative to the path parameter to filter fixes by. Only fixes affecting these files will be returned. INCOMPATIBLE with fetchFixesFromAnyFile.
‚Ä¢ fetchFixesFromAnyFile ‚Äì if true, fetches fixes for all files in the repository. If false or not set (default), filters fixes to only those affecting files with changes in git status. INCOMPATIBLE with fileFilter.

The tool will:
1. Validate that the provided path is secure and exists.
2. Verify that the directory is a valid Git repository with an "origin" remote.
3. Apply file filtering based on parameters (see below).
4. Query the MOBB service by the origin remote URL and return a textual summary of available fixes (total and by severity) or a message if none are found.

File Filtering Behavior:
‚Ä¢ If fetchFixesFromAnyFile is true: Returns fixes for all files (no filtering).
‚Ä¢ If fileFilter is provided: Returns only fixes affecting the specified files.
‚Ä¢ If neither is provided (default): Returns only fixes affecting files with changes in git status.
‚Ä¢ If BOTH are provided: Returns an error (parameters are mutually exclusive).

Call this tool instead of scan_and_fix_vulnerabilities when you only need a fixes summary and do NOT want to perform scanning or code modifications.",
      "inputSchema": {
        "properties": {
          "fetchFixesFromAnyFile": {
            "description": "[Optional] if true, fetches fixes for all files in the repository. If false or not set, filters fixes to only those affecting files with changes in git status. INCOMPATIBLE with fileFilter",
            "type": "boolean",
          },
          "fileFilter": {
            "description": "[Optional] list of file paths relative to the path parameter to filter fixes by. Only fixes affecting these files will be returned. INCOMPATIBLE with fetchFixesFromAnyFile",
            "items": {
              "type": "string",
            },
            "type": "array",
          },
          "limit": {
            "description": "[Optional] maximum number of results to return",
            "type": "number",
          },
          "offset": {
            "description": "[Optional] offset for pagination",
            "type": "number",
          },
          "path": {
            "description": "Full local path to the cloned git repository to check for available fixes",
            "type": "string",
          },
        },
        "required": [
          "path",
        ],
        "type": "object",
      },
      "name": "fetch_available_fixes",
    },
    {
      "description": "Continuesly monitors your code and scans for new security vulnerabilities.

When to invoke:
‚Ä¢ ALWAYS call this tool ONCE at the very end of every reasoning / code-generation session (after all code edits, linting, tests, etc.).
‚Ä¢ Invoke when the user explicitly asks to "check for new fixes", "look for fresh patches", or similar.
‚Ä¢ The repository must exist locally and be a valid Git repo with an 'origin' remote configured.

How to invoke:
‚Ä¢ Required argument:
  ‚Äì path (string): absolute path to the repository root.

Behaviour:
‚Ä¢ If auto-fix is enabled: Returns a list of fixes that were automatically applied to your codebase.
‚Ä¢ If auto-fix is disabled: Returns a list of fresh fixes available for manual review and application.
‚Ä¢ If no fixes are available, it returns a concise message indicating so.
‚Ä¢ Results include a human-readable summary with total count and severity breakdown.

Example payload:
{
  "path": "/home/user/my-project"
}",
      "inputSchema": {
        "properties": {
          "path": {
            "description": "Full local path to the cloned git repository to check for new available fixes",
            "type": "string",
          },
        },
        "required": [
          "path",
        ],
        "type": "object",
      },
      "name": "check_for_new_available_fixes",
    },
  ],
}
`;
