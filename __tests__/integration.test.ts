import fs from 'node:fs'
import os from 'node:os'
import path from 'node:path'
import { setTimeout } from 'node:timers/promises'

import { API_URL, SCANNERS, WEB_APP_URL } from '@mobb/bugsy/constants'
import { runAnalysis } from '@mobb/bugsy/features/analysis'
import { getRelevantVulenrabilitiesFromDiff } from '@mobb/bugsy/features/analysis/add_fix_comments_for_pr'
import {
  fetchWithProxy,
  GQLClient,
} from '@mobb/bugsy/features/analysis/graphql'
import {
  MOBB_ICON_IMG,
  REPORT_DEFAULT_FILE_NAME,
  scmCloudUrl,
  ScmLibScmType,
  ScmType,
} from '@mobb/bugsy/features/analysis/scm'
import { PerformCliLoginDocument } from '@mobb/bugsy/features/analysis/scm/generates/client_generates'
import { GithubSCMLib } from '@mobb/bugsy/features/analysis/scm/github/GithubSCMLib'
import { createScmLib } from '@mobb/bugsy/features/analysis/scm/scmFactory'
import { mobbCliCommand } from '@mobb/bugsy/types'
import AdmZip from 'adm-zip'
import * as dotenv from 'dotenv'
import { HttpsProxyAgent } from 'https-proxy-agent'
import * as openExport from 'open'
import { beforeEach, describe, expect, it, vi } from 'vitest'
import { z } from 'zod'

import * as commandsExports from '../src/commands'
import { PROJECT_PAGE_REGEX } from '../src/constants'
import * as analysisExports from '../src/features/analysis'
import * as ourPackModule from '../src/features/analysis/pack'
import { pack } from '../src/features/analysis/pack'

dotenv.config({
  path: path.join(__dirname, '../../../__tests__/.env'),
})

const TEST_GITHUB_TOKEN = z
  .string()
  .parse(process.env['TEST_GITHUB_FIXER_TOKEN'])
const uuidRegex = '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}'
const analysisRegex = new RegExp(
  `organization/${uuidRegex}/project/${uuidRegex}/report/${uuidRegex}`
)

const GITHUB_FIXER_REPO_FIXABLE_ISSUE = {
  URL: 'https://github.com/mobb-dev/gh-fixer',
  COMMIT_HASH: '50e88318fdfa81ee9f6869fb70a66d028cf5222c',
  REF: 'vul-pr-fixable',
  PR_NUMBER: 2627,
} as const

const GITHUB_FIXER_REPO_FIXABLE_IRRELEVANT_AUTO_GENERATED_CODE_ISSUE = {
  URL: 'https://github.com/mobb-dev/gh-fixer',
  COMMIT_HASH: '781bd716f154a93184838d5ab9670119f5b3b820',
  REF: 'vul-pr-fixable-irrelevant-autogenerated-code',
  PR_NUMBER: 2634,
} as const

const GITHUB_FIXER_REPO_FIXABLE_IRRELEVANT_TEST_CODE_ISSUE = {
  URL: 'https://github.com/mobb-dev/gh-fixer',
  COMMIT_HASH: '5b82eec3370ed8274c126ea3ca573d5c9056dca8',
  REF: 'vul-pr-fixable-irrelevant-test-code',
  PR_NUMBER: 2636,
} as const

const GITHUB_FIXER_REPO_FIXABLE_IRRELEVANT_AUXILIARY_CODE_ISSUE = {
  URL: 'https://github.com/mobb-dev/gh-fixer',
  COMMIT_HASH: '8e1103a093d4dc7a0d604fd4f621adcd9380cc40',
  REF: 'vul-pr-fixable-irrelevant-auxiliary-code',
  PR_NUMBER: 2637,
} as const

const GITHUB_FIXER_REPO_FIXABLE_IRRELEVANT_VENDOR_CODE_ISSUE = {
  URL: 'https://github.com/mobb-dev/gh-fixer',
  COMMIT_HASH: '7e5454ff3c773df454018252749c291466d0edfb',
  REF: 'vul-pr-fixable-irrelevant-vendor-code',
  PR_NUMBER: 2639,
} as const

const GITHUB_FIXER_REPO_NOT_FIXABLE_IRRELEVANT_FALSE_POSITIVE_ISSUE = {
  URL: 'https://github.com/mobb-dev/gh-fixer',
  COMMIT_HASH: 'ecdaf4d681dcdbb54ca60e209e22010140cfd77e',
  REF: 'vul-pr-not-fixable-irrelevant-false-positive-llm',
  PR_NUMBER: 3181,
} as const

const fixMessageContent = `# ![image](${MOBB_ICON_IMG}) XSS fix is ready`
const irrelevantIssueMessageContent = `# ![image](${MOBB_ICON_IMG}) Irrelevant issues were spotted - no action required`

const token = z.string().parse(process.env['TOKEN'])
const mockedOpen = vi.spyOn(openExport, 'default')

vi.mock('open', () => ({
  default: vi.fn().mockImplementation(async (url: string) => {
    const match = url.match(/\/cli-login\/(.*?)\?.*$/)
    if (match && match.length == 2) {
      const loginId = match[1]
      const gqlClient = new GQLClient({
        token,
        type: 'token',
      })
      await gqlClient.createCommunityUser()
      // Emulate "Authenticate" button click in the Web UI.
      const performLoginRes = await fetchWithProxy(API_URL, {
        headers: {
          authorization: `Bearer ${token}`,
        },
        body: JSON.stringify({
          query: PerformCliLoginDocument,
          variables: {
            loginId,
          },
        }),
        method: 'POST',
      })
      expect(performLoginRes.status).toStrictEqual(200)
      await gqlClient.updateScmToken({
        scmType: ScmType.GitHub,
        url: scmCloudUrl.GitHub,
        org: undefined,
        refreshToken: undefined,
        token: TEST_GITHUB_TOKEN,
      })
    }
  }),
}))

vi.mock('../src/features/analysis/scanners/snyk', () => ({
  getSnykReport: vi.fn().mockImplementation(async (reportPath) => {
    fs.copyFileSync(path.join(__dirname, REPORT_DEFAULT_FILE_NAME), reportPath)
    return true
  }),
}))

beforeEach(() => {
  vi.clearAllMocks() // Clear all spy calls
})

it('test manifest files are included in zip upload', async () => {
  const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'mobb-cli-test-pack'))
  const zip = new AdmZip(
    path.join(
      __dirname,
      '..',
      '..',
      '..',
      'services',
      'node_general_backend',
      'src',
      'maintenance',
      'try_now',
      'juice-shop',
      'repo.zip'
    )
  )
  zip.extractAllTo(tmpDir)
  const buffer = await pack(tmpDir, ['package.json', 'routes/dataExport.ts'])
  const updatedZip = new AdmZip(buffer)
  expect(updatedZip.getEntries().length).toBe(3)
  updatedZip.getEntries().forEach((entry) => {
    expect([
      'package.json',
      'frontend/package.json',
      'routes/dataExport.ts',
    ]).toContain(entry.entryName)
  })
}, 30000)

describe('Basic Analyze tests', () => {
  it('Full analyze flow', async () => {
    mockedOpen.mockClear()
    const httpsProxyAgentConnectSpy = vi.spyOn(
      HttpsProxyAgent.prototype,
      'connect'
    )
    const runAnalysisSpy = vi.spyOn(analysisExports, 'runAnalysis')
    const autoPrAnalysisSpy = vi.spyOn(GQLClient.prototype, 'autoPrAnalysis')
    await analysisExports.runAnalysis(
      {
        repo: 'https://github.com/mobb-dev/simple-vulnerable-java-project',
        scanner: SCANNERS.Snyk,
        ci: false,
        command: 'scan',
        autoPr: true,
        commitDirectly: true,
        pullRequest: 1,
      },
      { skipPrompts: true }
    )

    //This test, when executed with a proxy, only calls the https proxy class for websocket connections
    //This validation here is to make sure that we do use the proxy when needed for websocket connections
    if (process.env['HTTP_PROXY']) {
      expect(httpsProxyAgentConnectSpy).toHaveBeenCalled()
    } else {
      expect(httpsProxyAgentConnectSpy).not.toHaveBeenCalled()
    }
    expect(runAnalysisSpy).toHaveBeenCalled()
    expect(autoPrAnalysisSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        analysisId: expect.any(String),
        commitDirectly: true,
        prId: 1,
        prStrategy: 'SPREAD',
      })
    )
    expect(mockedOpen).toHaveBeenCalledTimes(2)
    expect(mockedOpen).toBeCalledWith(expect.stringMatching(PROJECT_PAGE_REGEX))
  }, 30000)

  it('add-scm-token good token', async () => {
    mockedOpen.mockClear()
    const addScmTokenSpy = vi.spyOn(commandsExports, 'addScmToken')
    await commandsExports.addScmToken({
      token: TEST_GITHUB_TOKEN,
      scmType: ScmType.GitHub,
      url: scmCloudUrl.GitHub,
      'scm-type': ScmType.GitHub,
      ci: true,
      _: [],
      $0: '',
    })

    expect(addScmTokenSpy).toHaveBeenCalled()
    expect(addScmTokenSpy).not.toThrowError()
  }, 30000)

  it('add-scm-token bad token', async () => {
    mockedOpen.mockClear()
    await expect(
      commandsExports.addScmToken({
        token: 'bad-token',
        scmType: ScmType.GitHub,
        url: scmCloudUrl.GitHub,
        'scm-type': ScmType.GitHub,
        ci: true,
        _: [],
        $0: '',
      })
    ).rejects.toThrowError('Invalid SCM credentials')
  }, 30000)

  it('add-scm-token bad cloud url', async () => {
    mockedOpen.mockClear()
    await expect(
      commandsExports.addScmToken({
        token: TEST_GITHUB_TOKEN,
        scmType: ScmType.GitHub,
        url: 'https://gitbadscmdomain.com/a/b',
        'scm-type': ScmType.GitHub,
        ci: true,
        _: [],
        $0: '',
      })
    ).rejects.toThrowError('Mobb could not reach the repository')
  }, 30000)

  it.each(['assets', 'assets/simple', 'assets/simple/src'])(
    'Direct repo upload',
    async (srcPath) => {
      const packSpy = vi.spyOn(ourPackModule, 'pack')
      const autoPrAnalysisSpy = vi.spyOn(GQLClient.prototype, 'autoPrAnalysis')
      mockedOpen.mockClear()
      await analysisExports.runAnalysis(
        {
          repo: 'https://bitbucket.com/a/b',
          ref: 'test',
          commitHash: 'ad00119b0d4a56f44a49d3d20eccb77978a363f8',
          scanFile: path.join(__dirname, 'assets/simple/codeql_report.json'),
          srcPath: path.join(__dirname, srcPath),
          ci: false,
          command: 'analyze',
        },
        { skipPrompts: true }
      )
      expect(mockedOpen).toHaveBeenCalledTimes(2)
      expect(autoPrAnalysisSpy).not.toHaveBeenCalled()
      expect(mockedOpen).toBeCalledWith(
        expect.stringMatching(PROJECT_PAGE_REGEX)
      )
      // ensure that we filter only relevant files
      const packedResult = await packSpy.mock.results[0]?.value
      const uploadedRepoZip = new AdmZip(Buffer.from(packedResult))
      expect(uploadedRepoZip.getEntryCount()).toBe(1)
    }
  )

  it('Direct repo upload from FPR file', async () => {
    const packSpy = vi.spyOn(ourPackModule, 'repackFpr')
    const autoPrAnalysisSpy = vi.spyOn(GQLClient.prototype, 'autoPrAnalysis')
    mockedOpen.mockClear()
    await analysisExports.runAnalysis(
      {
        repo: 'https://bitbucket.com/a/b',
        ref: 'test',
        commitHash: 'ad00119b0d4a56f44a49d3d20eccb77978a363f8',
        scanFile: path.join(__dirname, 'assets/scandata.fpr'),
        srcPath: path.join(__dirname, 'assets/scandata.fpr'),
        ci: false,
        command: 'analyze',
      },
      { skipPrompts: true }
    )
    expect(mockedOpen).toHaveBeenCalledTimes(2)
    expect(autoPrAnalysisSpy).not.toHaveBeenCalled()
    expect(mockedOpen).toBeCalledWith(expect.stringMatching(PROJECT_PAGE_REGEX))
    // ensure that we filter only relevant files
    const packedResult = await packSpy.mock.results[0]?.value
    const uploadedRepoZip = new AdmZip(Buffer.from(packedResult))
    expect(uploadedRepoZip.getEntryCount()).toBe(12)
  })

  it('Checks ci flag', async () => {
    const consoleMock = vi.spyOn(console, 'log')
    const autoPrAnalysisSpy = vi.spyOn(GQLClient.prototype, 'autoPrAnalysis')
    const prNumber = 1
    await analysisExports.runAnalysis(
      {
        repo: 'https://bitbucket.com/a/b',
        ref: 'test',
        commitHash: 'ad00119b0d4a56f44a49d3d20eccb77978a363f8',
        scanFile: path.join(__dirname, 'assets/simple/codeql_report.json'),
        srcPath: path.join(__dirname, 'assets'),
        ci: true,
        command: 'analyze',
        autoPr: true,
        commitDirectly: true,
        pullRequest: prNumber,
      },
      { skipPrompts: true }
    )
    expect(autoPrAnalysisSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        analysisId: expect.any(String),
        commitDirectly: true,
        prId: prNumber,
        prStrategy: 'SPREAD',
      })
    )
    expect(analysisRegex.test(consoleMock.mock.lastCall?.at(0))).toBe(true)
    consoleMock.mockClear()
  })
  it('Should run the github fixer command - fixable issue', async () => {
    const reportPath = path.join(
      __dirname,
      'assets/github_fixer_demo/snyk_report.json'
    )
    const autoPrAnalysisSpy = vi.spyOn(GQLClient.prototype, 'autoPrAnalysis')
    const scm = await createScmLib({
      url: GITHUB_FIXER_REPO_FIXABLE_ISSUE.URL,
      scmType: ScmLibScmType.GITHUB,
      accessToken: TEST_GITHUB_TOKEN,
      scmOrg: undefined,
    })
    if (!(scm instanceof GithubSCMLib)) {
      throw new Error('SCM is not GithubSCMLib')
    }
    // todo: for some reason, the type is not inferred correctly when building while ide shows it correctly
    const castedScm = scm as GithubSCMLib

    const analysisId = await runAnalysis(
      {
        repo: GITHUB_FIXER_REPO_FIXABLE_ISSUE.URL,
        ref: GITHUB_FIXER_REPO_FIXABLE_ISSUE.REF,
        commitHash: GITHUB_FIXER_REPO_FIXABLE_ISSUE.COMMIT_HASH,
        scanner: SCANNERS.Snyk,
        pullRequest: GITHUB_FIXER_REPO_FIXABLE_ISSUE.PR_NUMBER,
        githubToken: TEST_GITHUB_TOKEN,
        scanFile: reportPath,
        command: mobbCliCommand.review,
        ci: true,
      },
      { skipPrompts: true }
    )

    const gqlClient = new GQLClient({
      token,
      type: 'token',
    })
    expect(autoPrAnalysisSpy).not.toHaveBeenCalled()

    const pullRequestNumber = GITHUB_FIXER_REPO_FIXABLE_ISSUE.PR_NUMBER
    const getAnalysis = await gqlClient.getAnalysis(analysisId)
    const {
      vulnerabilityReport: {
        projectId,
        project: { organizationId },
      },
    } = getAnalysis

    const diff = await castedScm.getPrDiff({ pull_number: pullRequestNumber })
    const prVulenrabilities = await getRelevantVulenrabilitiesFromDiff({
      diff,
      gqlClient,
      vulnerabilityReportId: getAnalysis.vulnerabilityReportId,
    })

    // Need to wait to make sure the comments are updated
    await setTimeout(3000)
    const comments = await castedScm.getPrComments({
      pull_number: pullRequestNumber,
    })

    expect(prVulenrabilities.fixablePrVuls).toBe(1)
    expect(prVulenrabilities.nonFixablePrVuls).toBe(0)
    expect(prVulenrabilities.totalPrVulnerabilities).toBe(1)
    expect(prVulenrabilities.totalScanVulnerabilities).toBe(2)
    expect(prVulenrabilities.vulnerabilitiesOutsidePr).toBe(1)
    expect(prVulenrabilities.irrelevantVulnerabilityReportIssues?.length).toBe(
      0
    )

    const [prComment] = comments.data
    if (!prComment) {
      throw new Error('PR comment not found')
    }
    const [fixId] = prVulenrabilities.vulnerabilityReportIssueCodeNodes.map(
      ({ vulnerabilityReportIssue: { fixId } }) => fixId
    )
    expect(comments.data.length).toBe(1)

    const searchParams = new URLSearchParams()
    searchParams.append('commit_redirect_url', prComment.html_url)
    searchParams.append('comment_id', prComment.id.toString())

    const fixUrl = `${WEB_APP_URL}/organization/${organizationId}/project/${projectId}/report/${analysisId}/fix/${fixId}?${searchParams.toString()}`

    expect(prComment.body.startsWith(fixMessageContent)).toBe(true)
    expect(prComment.body.split('\n').pop()).toBe(
      `[Learn more and fine tune the fix](${fixUrl})`
    )
  })

  it('Should run the github fixer command - irrelevant autogenerated code fixable issue', async () => {
    const reportPath = path.join(
      __dirname,
      'assets/github_fixer_demo/irrelevant_autogenerated_code/snyk_report.json'
    )

    const autoPrAnalysisSpy = vi.spyOn(GQLClient.prototype, 'autoPrAnalysis')
    const scm = await createScmLib({
      url: GITHUB_FIXER_REPO_FIXABLE_IRRELEVANT_AUTO_GENERATED_CODE_ISSUE.URL,
      scmType: ScmLibScmType.GITHUB,
      accessToken: TEST_GITHUB_TOKEN,
      scmOrg: undefined,
    })

    if (!(scm instanceof GithubSCMLib)) {
      throw new Error('SCM is not GithubSCMLib')
    }
    // todo: for some reason, the type is not inferred correctly when building while ide shows it correctly
    const castedScm = scm as GithubSCMLib

    const analysisId = await runAnalysis(
      {
        repo: GITHUB_FIXER_REPO_FIXABLE_IRRELEVANT_AUTO_GENERATED_CODE_ISSUE.URL,
        ref: GITHUB_FIXER_REPO_FIXABLE_IRRELEVANT_AUTO_GENERATED_CODE_ISSUE.REF,
        commitHash:
          GITHUB_FIXER_REPO_FIXABLE_IRRELEVANT_AUTO_GENERATED_CODE_ISSUE.COMMIT_HASH,
        scanner: SCANNERS.Snyk,
        pullRequest:
          GITHUB_FIXER_REPO_FIXABLE_IRRELEVANT_AUTO_GENERATED_CODE_ISSUE.PR_NUMBER,
        githubToken: TEST_GITHUB_TOKEN,
        scanFile: reportPath,
        command: mobbCliCommand.review,
        ci: true,
        experimentalEnabled: true,
      },
      { skipPrompts: true }
    )

    const gqlClient = new GQLClient({
      token,
      type: 'token',
    })
    expect(autoPrAnalysisSpy).not.toHaveBeenCalled()

    const pullRequestNumber =
      GITHUB_FIXER_REPO_FIXABLE_IRRELEVANT_AUTO_GENERATED_CODE_ISSUE.PR_NUMBER
    const getAnalysis = await gqlClient.getAnalysis(analysisId)
    const {
      vulnerabilityReport: {
        projectId,
        project: { organizationId },
      },
    } = getAnalysis

    const diff = await castedScm.getPrDiff({ pull_number: pullRequestNumber })
    const prVulenrabilities = await getRelevantVulenrabilitiesFromDiff({
      diff,
      gqlClient,
      vulnerabilityReportId: getAnalysis.vulnerabilityReportId,
    })

    // Need to wait to make sure the comments are updated
    await setTimeout(3000)

    const comments = await castedScm.getPrComments({
      pull_number: pullRequestNumber,
    })

    expect(prVulenrabilities.fixablePrVuls).toBe(1)
    expect(prVulenrabilities.nonFixablePrVuls).toBe(0)
    expect(prVulenrabilities.totalPrVulnerabilities).toBe(1)
    expect(prVulenrabilities.totalScanVulnerabilities).toBe(3)
    expect(prVulenrabilities.vulnerabilitiesOutsidePr).toBe(2)

    const [prComment] = comments.data
    if (!prComment) {
      throw new Error('PR comment not found')
    }
    const [vulnerabilityReportIssueId] =
      prVulenrabilities.vulnerabilityReportIssueCodeNodes.map(
        ({ vulnerabilityReportIssueId }) => vulnerabilityReportIssueId
      )
    expect(comments.data.length).toBe(1)

    const searchParams = new URLSearchParams()
    searchParams.append('commit_redirect_url', prComment.html_url)
    searchParams.append('comment_id', prComment.id.toString())

    const fixUrl = `${WEB_APP_URL}/organization/${organizationId}/project/${projectId}/report/${analysisId}/issue/${vulnerabilityReportIssueId}?${searchParams.toString()}`

    expect(prComment.body.startsWith(fixMessageContent)).toBe(true)
    expect(prComment.body.split('\n').pop()).toBe(
      `[Learn more and fine tune the fix](${fixUrl})`
    )
  })

  it('Should run the github fixer command - irrelevant test code fixable issue', async () => {
    const reportPath = path.join(
      __dirname,
      'assets/github_fixer_demo/irrelevant_test_code/snyk_report.json'
    )
    const autoPrAnalysisSpy = vi.spyOn(GQLClient.prototype, 'autoPrAnalysis')
    const scm = await createScmLib({
      url: GITHUB_FIXER_REPO_FIXABLE_IRRELEVANT_TEST_CODE_ISSUE.URL,
      scmType: ScmLibScmType.GITHUB,
      accessToken: TEST_GITHUB_TOKEN,
      scmOrg: undefined,
    })

    if (!(scm instanceof GithubSCMLib)) {
      throw new Error('SCM is not GithubSCMLib')
    }
    // todo: for some reason, the type is not inferred correctly when building while ide shows it correctly
    const castedScm = scm as GithubSCMLib

    const analysisId = await runAnalysis(
      {
        repo: GITHUB_FIXER_REPO_FIXABLE_IRRELEVANT_TEST_CODE_ISSUE.URL,
        ref: GITHUB_FIXER_REPO_FIXABLE_IRRELEVANT_TEST_CODE_ISSUE.REF,
        commitHash:
          GITHUB_FIXER_REPO_FIXABLE_IRRELEVANT_TEST_CODE_ISSUE.COMMIT_HASH,
        scanner: SCANNERS.Snyk,
        pullRequest:
          GITHUB_FIXER_REPO_FIXABLE_IRRELEVANT_TEST_CODE_ISSUE.PR_NUMBER,
        githubToken: TEST_GITHUB_TOKEN,
        scanFile: reportPath,
        command: mobbCliCommand.review,
        ci: true,
        experimentalEnabled: true,
      },
      { skipPrompts: true }
    )

    const gqlClient = new GQLClient({
      token,
      type: 'token',
    })
    expect(autoPrAnalysisSpy).not.toHaveBeenCalled()

    const pullRequestNumber =
      GITHUB_FIXER_REPO_FIXABLE_IRRELEVANT_TEST_CODE_ISSUE.PR_NUMBER
    const getAnalysis = await gqlClient.getAnalysis(analysisId)
    const {
      vulnerabilityReport: {
        projectId,
        project: { organizationId },
      },
    } = getAnalysis

    const diff = await castedScm.getPrDiff({ pull_number: pullRequestNumber })
    const prVulenrabilities = await getRelevantVulenrabilitiesFromDiff({
      diff,
      gqlClient,
      vulnerabilityReportId: getAnalysis.vulnerabilityReportId,
    })

    // Need to wait to make sure the comments are updated
    await setTimeout(3000)
    const comments = await castedScm.getPrComments({
      pull_number: pullRequestNumber,
    })

    expect(prVulenrabilities.fixablePrVuls).toBe(1)
    expect(prVulenrabilities.nonFixablePrVuls).toBe(0)
    expect(prVulenrabilities.totalPrVulnerabilities).toBe(1)
    expect(prVulenrabilities.totalScanVulnerabilities).toBe(2)
    expect(prVulenrabilities.vulnerabilitiesOutsidePr).toBe(1)
    expect(prVulenrabilities.irrelevantVulnerabilityReportIssues?.length).toBe(
      0
    )

    const [prComment] = comments.data
    if (!prComment) {
      throw new Error('PR comment not found')
    }
    const [vulnerabilityReportIssueId] =
      prVulenrabilities.vulnerabilityReportIssueCodeNodes.map(
        ({ vulnerabilityReportIssueId }) => vulnerabilityReportIssueId
      )
    expect(comments.data.length).toBe(1)

    const searchParams = new URLSearchParams()
    searchParams.append('commit_redirect_url', prComment.html_url)
    searchParams.append('comment_id', prComment.id.toString())

    const fixUrl = `${WEB_APP_URL}/organization/${organizationId}/project/${projectId}/report/${analysisId}/issue/${vulnerabilityReportIssueId}?${searchParams.toString()}`

    expect(prComment.body.startsWith(fixMessageContent)).toBe(true)
    expect(prComment.body.split('\n').pop()).toBe(
      `[Learn more and fine tune the fix](${fixUrl})`
    )
  })

  it('Should run the github fixer command - irrelevant auxilary code fixable issue', async () => {
    const reportPath = path.join(
      __dirname,
      'assets/github_fixer_demo/irrelevant_auxiliary_code/snyk_report.json'
    )
    const autoPrAnalysisSpy = vi.spyOn(GQLClient.prototype, 'autoPrAnalysis')
    const scm = await createScmLib({
      url: GITHUB_FIXER_REPO_FIXABLE_IRRELEVANT_AUXILIARY_CODE_ISSUE.URL,
      scmType: ScmLibScmType.GITHUB,
      accessToken: TEST_GITHUB_TOKEN,
      scmOrg: undefined,
    })
    if (!(scm instanceof GithubSCMLib)) {
      throw new Error('SCM is not GithubSCMLib')
    }
    // todo: for some reason, the type is not inferred correctly when building while ide shows it correctly
    const castedScm = scm as GithubSCMLib

    const analysisId = await runAnalysis(
      {
        repo: GITHUB_FIXER_REPO_FIXABLE_IRRELEVANT_AUXILIARY_CODE_ISSUE.URL,
        ref: GITHUB_FIXER_REPO_FIXABLE_IRRELEVANT_AUXILIARY_CODE_ISSUE.REF,
        commitHash:
          GITHUB_FIXER_REPO_FIXABLE_IRRELEVANT_AUXILIARY_CODE_ISSUE.COMMIT_HASH,
        scanner: SCANNERS.Snyk,
        pullRequest:
          GITHUB_FIXER_REPO_FIXABLE_IRRELEVANT_AUXILIARY_CODE_ISSUE.PR_NUMBER,
        githubToken: TEST_GITHUB_TOKEN,
        scanFile: reportPath,
        command: mobbCliCommand.review,
        ci: true,
        experimentalEnabled: true,
      },
      { skipPrompts: true }
    )

    const gqlClient = new GQLClient({
      token,
      type: 'token',
    })
    expect(autoPrAnalysisSpy).not.toHaveBeenCalled()

    const pullRequestNumber =
      GITHUB_FIXER_REPO_FIXABLE_IRRELEVANT_AUXILIARY_CODE_ISSUE.PR_NUMBER
    const getAnalysis = await gqlClient.getAnalysis(analysisId)
    const {
      vulnerabilityReport: {
        projectId,
        project: { organizationId },
      },
    } = getAnalysis

    const diff = await castedScm.getPrDiff({ pull_number: pullRequestNumber })
    const prVulenrabilities = await getRelevantVulenrabilitiesFromDiff({
      diff,
      gqlClient,
      vulnerabilityReportId: getAnalysis.vulnerabilityReportId,
    })

    // Need to wait to make sure the comments are updated
    await setTimeout(3000)
    const comments = await castedScm.getPrComments({
      pull_number: pullRequestNumber,
    })

    expect(prVulenrabilities.fixablePrVuls).toBe(1)
    expect(prVulenrabilities.nonFixablePrVuls).toBe(0)
    expect(prVulenrabilities.totalPrVulnerabilities).toBe(1)
    expect(prVulenrabilities.totalScanVulnerabilities).toBe(2)
    expect(prVulenrabilities.vulnerabilitiesOutsidePr).toBe(1)
    expect(prVulenrabilities.irrelevantVulnerabilityReportIssues?.length).toBe(
      0
    )

    const [prComment] = comments.data
    if (!prComment) {
      throw new Error('PR comment not found')
    }
    const [vulnerabilityReportIssueId] =
      prVulenrabilities.vulnerabilityReportIssueCodeNodes.map(
        ({ vulnerabilityReportIssueId }) => vulnerabilityReportIssueId
      )
    expect(comments.data.length).toBe(1)

    const searchParams = new URLSearchParams()
    searchParams.append('commit_redirect_url', prComment.html_url)
    searchParams.append('comment_id', prComment.id.toString())

    const fixUrl = `${WEB_APP_URL}/organization/${organizationId}/project/${projectId}/report/${analysisId}/issue/${vulnerabilityReportIssueId}?${searchParams.toString()}`

    expect(prComment.body.startsWith(fixMessageContent)).toBe(true)
    expect(prComment.body.split('\n').pop()).toBe(
      `[Learn more and fine tune the fix](${fixUrl})`
    )
  })

  it('Should run the github fixer command - irrelevant vendor code fixable issue', async () => {
    const reportPath = path.join(
      __dirname,
      'assets/github_fixer_demo/irrelevant_vendor_code/snyk_report.json'
    )
    const autoPrAnalysisSpy = vi.spyOn(GQLClient.prototype, 'autoPrAnalysis')
    const scm = await createScmLib({
      url: GITHUB_FIXER_REPO_FIXABLE_IRRELEVANT_VENDOR_CODE_ISSUE.URL,
      scmType: ScmLibScmType.GITHUB,
      accessToken: TEST_GITHUB_TOKEN,
      scmOrg: undefined,
    })
    if (!(scm instanceof GithubSCMLib)) {
      throw new Error('SCM is not GithubSCMLib')
    }
    // todo: for some reason, the type is not inferred correctly when building while ide shows it correctly
    const castedScm = scm as GithubSCMLib

    const analysisId = await runAnalysis(
      {
        repo: GITHUB_FIXER_REPO_FIXABLE_IRRELEVANT_VENDOR_CODE_ISSUE.URL,
        ref: GITHUB_FIXER_REPO_FIXABLE_IRRELEVANT_VENDOR_CODE_ISSUE.REF,
        commitHash:
          GITHUB_FIXER_REPO_FIXABLE_IRRELEVANT_VENDOR_CODE_ISSUE.COMMIT_HASH,
        scanner: SCANNERS.Snyk,
        pullRequest:
          GITHUB_FIXER_REPO_FIXABLE_IRRELEVANT_VENDOR_CODE_ISSUE.PR_NUMBER,
        githubToken: TEST_GITHUB_TOKEN,
        scanFile: reportPath,
        command: mobbCliCommand.review,
        ci: true,
        experimentalEnabled: true,
      },
      { skipPrompts: true }
    )

    const gqlClient = new GQLClient({
      token,
      type: 'token',
    })
    expect(autoPrAnalysisSpy).not.toHaveBeenCalled()

    const pullRequestNumber =
      GITHUB_FIXER_REPO_FIXABLE_IRRELEVANT_VENDOR_CODE_ISSUE.PR_NUMBER
    const getAnalysis = await gqlClient.getAnalysis(analysisId)
    const {
      vulnerabilityReport: {
        projectId,
        project: { organizationId },
      },
    } = getAnalysis

    const diff = await castedScm.getPrDiff({ pull_number: pullRequestNumber })
    const prVulenrabilities = await getRelevantVulenrabilitiesFromDiff({
      diff,
      gqlClient,
      vulnerabilityReportId: getAnalysis.vulnerabilityReportId,
    })

    // Need to wait to make sure the comments are updated
    await setTimeout(3000)
    const comments = await castedScm.getPrComments({
      pull_number: pullRequestNumber,
    })

    expect(prVulenrabilities.fixablePrVuls).toBe(1)
    expect(prVulenrabilities.nonFixablePrVuls).toBe(0)
    expect(prVulenrabilities.totalPrVulnerabilities).toBe(1)
    expect(prVulenrabilities.totalScanVulnerabilities).toBe(2)
    expect(prVulenrabilities.vulnerabilitiesOutsidePr).toBe(1)
    expect(prVulenrabilities.irrelevantVulnerabilityReportIssues?.length).toBe(
      0
    )

    const [prComment] = comments.data
    if (!prComment) {
      throw new Error('PR comment not found')
    }
    const [vulnerabilityReportIssueId] =
      prVulenrabilities.vulnerabilityReportIssueCodeNodes.map(
        ({ vulnerabilityReportIssueId }) => vulnerabilityReportIssueId
      )
    expect(comments.data.length).toBe(1)

    const searchParams = new URLSearchParams()
    searchParams.append('commit_redirect_url', prComment.html_url)
    searchParams.append('comment_id', prComment.id.toString())

    const fixUrl = `${WEB_APP_URL}/organization/${organizationId}/project/${projectId}/report/${analysisId}/issue/${vulnerabilityReportIssueId}?${searchParams.toString()}`

    expect(prComment.body.startsWith(fixMessageContent)).toBe(true)
    expect(prComment.body.split('\n').pop()).toBe(
      `[Learn more and fine tune the fix](${fixUrl})`
    )
  })

  it('Should run the github fixer command - irrelevant false positive code not fixable issue', async () => {
    const reportPath = path.join(
      __dirname,
      'assets/github_fixer_demo/false_positive_no_fix_llm/checkmarx_report.json'
    )
    const autoPrAnalysisSpy = vi.spyOn(GQLClient.prototype, 'autoPrAnalysis')
    const scm = await createScmLib({
      url: GITHUB_FIXER_REPO_NOT_FIXABLE_IRRELEVANT_FALSE_POSITIVE_ISSUE.URL,
      scmType: ScmLibScmType.GITHUB,
      accessToken: TEST_GITHUB_TOKEN,
      scmOrg: undefined,
    })
    if (scm instanceof GithubSCMLib === false) {
      throw new Error('SCM is not GithubSCMLib')
    }
    // todo: for some reason, the type is not inferred correctly when building while ide shows it correctly
    const castedScm = scm as GithubSCMLib

    const analysisId = await runAnalysis(
      {
        repo: GITHUB_FIXER_REPO_NOT_FIXABLE_IRRELEVANT_FALSE_POSITIVE_ISSUE.URL,
        ref: GITHUB_FIXER_REPO_NOT_FIXABLE_IRRELEVANT_FALSE_POSITIVE_ISSUE.REF,
        commitHash:
          GITHUB_FIXER_REPO_NOT_FIXABLE_IRRELEVANT_FALSE_POSITIVE_ISSUE.COMMIT_HASH,
        scanner: SCANNERS.Checkmarx,
        pullRequest:
          GITHUB_FIXER_REPO_NOT_FIXABLE_IRRELEVANT_FALSE_POSITIVE_ISSUE.PR_NUMBER,
        githubToken: TEST_GITHUB_TOKEN,
        scanFile: reportPath,
        command: mobbCliCommand.review,
        ci: true,
        experimentalEnabled: true,
      },
      { skipPrompts: true }
    )

    const gqlClient = new GQLClient({
      token,
      type: 'token',
    })
    expect(autoPrAnalysisSpy).not.toHaveBeenCalled()

    const pullRequestNumber =
      GITHUB_FIXER_REPO_NOT_FIXABLE_IRRELEVANT_FALSE_POSITIVE_ISSUE.PR_NUMBER
    const getAnalysis = await gqlClient.getAnalysis(analysisId)
    const {
      vulnerabilityReport: {
        projectId,
        project: { organizationId },
      },
    } = getAnalysis

    const diff = await castedScm.getPrDiff({ pull_number: pullRequestNumber })
    const prVulenrabilities = await getRelevantVulenrabilitiesFromDiff({
      diff,
      gqlClient,
      vulnerabilityReportId: getAnalysis.vulnerabilityReportId,
    })

    // Need to wait to make sure the comments are updated
    await setTimeout(3000)
    const [comments, generalPrComments] = await Promise.all([
      castedScm.getPrComments({ pull_number: pullRequestNumber }),
      castedScm.getGeneralPrComments({ prNumber: pullRequestNumber }),
    ])

    expect(prVulenrabilities.vulnerabilityReportIssueCodeNodes?.length).toBe(0)
    expect(prVulenrabilities.nonFixablePrVuls).toBe(1)
    expect(prVulenrabilities.fixablePrVuls).toBe(0)
    expect(prVulenrabilities.totalScanVulnerabilities).toBe(1)
    expect(prVulenrabilities.vulnerabilitiesOutsidePr).toBe(0)
    expect(prVulenrabilities.totalPrVulnerabilities).toBe(1)
    expect(prVulenrabilities.irrelevantVulnerabilityReportIssues?.length).toBe(
      1
    )

    const vr = prVulenrabilities.irrelevantVulnerabilityReportIssues[0]
    expect(vr).is.not.toBeNull()
    expect(vr?.fixId).is.toBeNull()
    expect(vr?.id).is.not.toBeNull()
    expect(vr?.category).toBe('FalsePositive')
    expect(vr?.vulnerabilityReportIssueTags?.length).toBe(1)
    expect(vr?.vulnerabilityReportIssueTags[0]?.tag).toBe('FALSE_POSITIVE')
    expect(vr?.codeNodes?.length).toBe(1)

    const [prComment] = comments.data
    if (!prComment) {
      throw new Error('PR comment not found')
    }

    expect(comments.data.length).toBe(1)

    const searchParams = new URLSearchParams()
    searchParams.append('commit_redirect_url', prComment.html_url)
    searchParams.append('comment_id', prComment.id.toString())

    const issueUrl = `${WEB_APP_URL}/organization/${organizationId}/project/${projectId}/report/${analysisId}/issue/${vr?.id}?${searchParams.toString()}`
    expect(generalPrComments.data[0]?.body).toMatchInlineSnapshot(`
       "# ![image](https://app.mobb.ai/gh-action/Logo_Rounded_Icon.svg) We couldn't fix the issues detected by **Checkmarx**
Mobb Fixer gets better and better every day, but unfortunately your current issues aren't supported yet.
For specific requests [contact us](https://content.mobb.ai/contact) and we'll do the most to answer your need quickly."
    `)
    expect(prComment.body.split('\n').pop()).toBe(
      `[Learn more about this issue](${issueUrl})`
    )

    comments.data.forEach((comment) => {
      expect(comment.body.startsWith(irrelevantIssueMessageContent)).toBe(true)
    })
  })
})

describe('create-one-pr flag tests', () => {
  it('should successfully run analysis with create-one-pr and auto-pr', async () => {
    const consoleMock = vi.spyOn(console, 'log')
    const autoPrAnalysisSpy = vi.spyOn(GQLClient.prototype, 'autoPrAnalysis')
    const prNumber = 1
    await analysisExports.runAnalysis(
      {
        repo: 'https://bitbucket.com/a/b',
        ref: 'test',
        commitHash: 'ad00119b0d4a56f44a49d3d20eccb77978a363f8',
        scanFile: path.join(__dirname, 'assets/simple/codeql_report.json'),
        srcPath: path.join(__dirname, 'assets'),
        ci: true,
        command: 'analyze',
        createOnePr: true,
        autoPr: true,
        commitDirectly: false,
        pullRequest: prNumber,
      },
      { skipPrompts: true }
    )
    expect(autoPrAnalysisSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        analysisId: expect.any(String),
        commitDirectly: false,
        prId: prNumber,
        prStrategy: 'CONDENSE',
      })
    )
    expect(analysisRegex.test(consoleMock.mock.lastCall?.at(0))).toBe(true)
    consoleMock.mockClear()
  })

  it('should successfully run analysis with create-one-pr and auto-pr in non-CI mode', async () => {
    const consoleMock = vi.spyOn(console, 'log')
    const autoPrAnalysisSpy = vi.spyOn(GQLClient.prototype, 'autoPrAnalysis')
    const mockedOpen = vi.spyOn(openExport, 'default')
    await analysisExports.runAnalysis(
      {
        repo: 'https://bitbucket.com/a/b',
        ref: 'test',
        commitHash: 'ad00119b0d4a56f44a49d3d20eccb77978a363f8',
        scanFile: path.join(__dirname, 'assets/simple/codeql_report.json'),
        srcPath: path.join(__dirname, 'assets'),
        ci: false,
        command: 'analyze',
        createOnePr: true,
        autoPr: true,
        commitDirectly: false,
      },
      { skipPrompts: true }
    )
    expect(autoPrAnalysisSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        analysisId: expect.any(String),
        commitDirectly: false,
        prId: undefined,
        prStrategy: 'CONDENSE',
      })
    )
    expect(mockedOpen).toHaveBeenCalledTimes(2)
    expect(mockedOpen).toBeCalledWith(expect.stringMatching(PROJECT_PAGE_REGEX))
    consoleMock.mockClear()
    mockedOpen.mockClear()
  })
})
