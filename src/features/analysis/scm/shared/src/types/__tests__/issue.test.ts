import nock from 'nock'
import { afterEach, beforeEach, describe, expect, it } from 'vitest'

import { Vulnerability_Report_Issue_Tag_Enum } from '../../../../generates/client_generates'
import { BaseIssuePartsZ, MAX_SOURCE_CODE_FILE_SIZE_IN_BYTES } from '../issue'

const FAKE_ORIGIN = 'https://example.com'

const paths = {
  valid: 'valid',
  invalid: 'invalid',
} as const

const FAKE_URL = {
  valid: `${FAKE_ORIGIN}/${paths.valid}`,
  invalid: `${FAKE_ORIGIN}/${paths.invalid}`,
} as const

function initNock() {
  nock(FAKE_ORIGIN)
    .get(`/${paths.valid}`)

    .reply(200, mockDiffContent, {
      'Content-Length': `${MAX_SOURCE_CODE_FILE_SIZE_IN_BYTES - 1}`, // Exceeds 100kB limit
    })
    .persist()

    .get(`/${paths.invalid}`)
    .reply(200, mockDiffContent, {
      'Content-Length': `${MAX_SOURCE_CODE_FILE_SIZE_IN_BYTES + 1}`, // Exceeds 100kB limit
    })
    .persist()
}

const mockDiffContent = 'mock diff content'
describe('BaseIssuePartsZ', () => {
  beforeEach(() => {
    initNock()

    // Enable Nock
    nock.disableNetConnect()
  })

  afterEach(() => {
    // Clean up all mocks
    nock.cleanAll()
    nock.enableNetConnect()
  })

  const validIssue = {
    id: '123e4567-e89b-12d3-a456-426614174000',
    safeIssueType: 'security_issue',
    safeIssueLanguage: 'typescript',
    createdAt: '2024-03-20T12:00:00Z',
    parsedSeverity: 'high',
    category: 'Fixable',
    vulnerabilityReportIssueTags: [
      { tag: Vulnerability_Report_Issue_Tag_Enum.AutogeneratedCode },
    ],
    codeNodes: [
      { path: 'src/app.ts', line: 42, index: 1 },
      { path: 'src/utils.ts', line: 15, index: 0 },
    ],
    sourceCodeNodes: [],
    vulnerabilityReportIssueNodeDiffFile: {
      signedFile: {
        url: FAKE_URL.valid,
      },
    },
  }

  it('should validate a correct issue object', async () => {
    const result = await BaseIssuePartsZ.safeParseAsync(validIssue)
    expect(result.success).toBe(true)
  })

  it('should handle missing optional fields', async () => {
    const issueWithoutOptionals = {
      ...validIssue,
      fix: null,
    }
    const result = await BaseIssuePartsZ.safeParseAsync(issueWithoutOptionals)
    expect(result.success).toBe(true)
  })

  it('should handle source code file fetch with size limit', async () => {
    const issueWithSourceCode = {
      ...validIssue,
      sourceCodeNodes: [
        {
          sourceCodeFile: {
            path: 'test.ts',
            signedFile: {
              url: FAKE_URL.valid,
            },
          },
        },
        {
          sourceCodeFile: {
            path: 'large-file.ts',
            signedFile: {
              url: FAKE_URL.invalid,
            },
          },
        },
      ],
    }

    const result = await BaseIssuePartsZ.parseAsync(issueWithSourceCode)
    const sourceNode = result.sourceCodeNodes[0]
    expect(result.sourceCodeNodes.length).toBe(1)
    expect(sourceNode?.fileContent).toBe(mockDiffContent)
  })

  it('should handle failed fetch requests', async () => {
    const issueWithBadUrl = {
      ...validIssue,
      vulnerabilityReportIssueNodeDiffFile: {
        signedFile: {
          url: 'https://example.com/bad-url',
        },
      },
    }

    nock('https://example.com').get('/bad-url').replyWithError('Network error')

    await expect(BaseIssuePartsZ.parseAsync(issueWithBadUrl)).rejects.toThrow()
  })
})
