import {
  Fix_Report_State_Enum,
  GetMcpFixesQuery,
  Scan_Source_Enum,
  SubmitVulnerabilityReportMutationVariables,
  UploadS3BucketInfoMutation,
} from '../../../features/analysis/scm/generates/client_generates'
import { uploadFile } from '../../../features/analysis/upload-file'
import { logError, logInfo } from '../../Logger'
import { FilePacking } from '../../services/FilePacking'
import { getMcpGQLClient, McpGQLClient } from '../../services/McpGQLClient'
import {
  ApiConnectionError,
  AuthenticationError,
  CliLoginError,
  FailedToGetApiTokenError,
  FileProcessingError,
  FileUploadError,
  GqlClientError,
  NoFilesError,
  ReportInitializationError,
  ScanError,
} from './errors/VulnerabilityFixErrors'
import {
  failedToAuthenticatePrompt,
  failedToConnectToApiPrompt,
  fixesPrompt,
} from './helpers/LLMResponsePrompts'

export const VUL_REPORT_DIGEST_TIMEOUT_MS = 1000 * 60 * 5 // 5 minutes in msec

export class VulnerabilityFixService {
  private gqlClient?: McpGQLClient
  private filePacking: FilePacking

  constructor() {
    this.filePacking = new FilePacking()
  }

  public async processVulnerabilities(
    fileList: string[],
    repositoryPath: string
  ): Promise<string> {
    try {
      this.validateFiles(fileList)
      this.gqlClient = await this.initializeGqlClient()

      const repoUploadInfo = await this.initializeReport()
      const zipBuffer = await this.packFiles(fileList, repositoryPath)
      await this.uploadFiles(zipBuffer, repoUploadInfo)

      const projectId = await this.getProjectId()
      await this.runScan({
        fixReportId: repoUploadInfo!.fixReportId,
        projectId,
      })

      const fixes = await this.getReportFixes(repoUploadInfo!.fixReportId)
      return fixesPrompt(fixes)
    } catch (error) {
      if (
        error instanceof ApiConnectionError ||
        error instanceof CliLoginError
      ) {
        return failedToConnectToApiPrompt
      }

      if (
        error instanceof AuthenticationError ||
        error instanceof FailedToGetApiTokenError
      ) {
        return failedToAuthenticatePrompt
      }

      const message = (error as Error).message
      logError('Vulnerability processing failed', { error: message })
      throw error
    }
  }

  private validateFiles(fileList: string[]): void {
    if (fileList.length === 0) {
      throw new NoFilesError()
    }
  }

  private async initializeGqlClient(): Promise<McpGQLClient> {
    const gqlClient = await getMcpGQLClient()

    const isConnected = await gqlClient.verifyConnection()
    if (!isConnected) {
      throw new ApiConnectionError(
        'Failed to connect to the API. Please check your API_KEY'
      )
    }

    return gqlClient
  }

  private async initializeReport(): Promise<
    UploadS3BucketInfoMutation['uploadS3BucketInfo']['repoUploadInfo']
  > {
    if (!this.gqlClient) {
      throw new GqlClientError()
    }

    try {
      const {
        uploadS3BucketInfo: { repoUploadInfo },
      } = await this.gqlClient.uploadS3BucketInfo()
      logInfo('Upload info retrieved', { uploadKey: repoUploadInfo?.uploadKey })
      return repoUploadInfo
    } catch (error) {
      const message = (error as Error).message
      throw new ReportInitializationError(
        `Error initializing report: ${message}`
      )
    }
  }

  private async packFiles(
    fileList: string[],
    repositoryPath: string
  ): Promise<Buffer> {
    try {
      const zipBuffer = await this.filePacking.packFiles(
        repositoryPath,
        fileList
      )
      logInfo('Files packed successfully', { fileCount: fileList.length })
      return zipBuffer
    } catch (error) {
      const message = (error as Error).message
      throw new FileProcessingError(`Error packing files: ${message}`)
    }
  }

  private async uploadFiles(
    zipBuffer: Buffer,
    repoUploadInfo: UploadS3BucketInfoMutation['uploadS3BucketInfo']['repoUploadInfo']
  ): Promise<void> {
    if (!repoUploadInfo) {
      throw new FileUploadError('Upload info is required')
    }

    try {
      await uploadFile({
        file: zipBuffer,
        url: repoUploadInfo.url,
        uploadFields: JSON.parse(repoUploadInfo.uploadFieldsJSON) as Record<
          string,
          string
        >,
        uploadKey: repoUploadInfo.uploadKey,
      })
      logInfo('File uploaded successfully')
    } catch (error) {
      logError('File upload failed', { error: (error as Error).message })
      throw new FileUploadError(
        `Failed to upload the file: ${(error as Error).message}`
      )
    }
  }

  private async getProjectId(): Promise<string> {
    if (!this.gqlClient) {
      throw new GqlClientError()
    }

    const projectId = await this.gqlClient.getProjectId()
    logInfo('Project ID retrieved', { projectId })
    return projectId
  }

  private async runScan(params: {
    fixReportId: string
    projectId: string
  }): Promise<void> {
    if (!this.gqlClient) {
      throw new GqlClientError()
    }

    const { fixReportId, projectId } = params
    logInfo('Starting scan', { fixReportId, projectId })

    const submitVulnerabilityReportVariables: SubmitVulnerabilityReportMutationVariables =
      {
        fixReportId,
        projectId,
        repoUrl: '',
        reference: 'no-branch',
        scanSource: Scan_Source_Enum.Cli,
      }

    logInfo('Submitting vulnerability report')
    const submitRes = await this.gqlClient.submitVulnerabilityReport(
      submitVulnerabilityReportVariables
    )

    if (
      submitRes.submitVulnerabilityReport.__typename !== 'VulnerabilityReport'
    ) {
      logError('Vulnerability report submission failed', {
        response: submitRes,
      })
      throw new ScanError('ðŸ•µï¸â€â™‚ï¸ Mobb analysis failed')
    }

    logInfo('Vulnerability report submitted successfully', {
      analysisId: submitRes.submitVulnerabilityReport.fixReportId,
    })

    logInfo('Starting analysis subscription')
    await this.gqlClient.subscribeToGetAnalysis({
      subscribeToAnalysisParams: {
        analysisId: submitRes.submitVulnerabilityReport.fixReportId,
      },
      callback: () => {
        /* empty */
      },
      callbackStates: [Fix_Report_State_Enum.Finished],
      timeoutInMs: VUL_REPORT_DIGEST_TIMEOUT_MS,
    })

    logInfo('Analysis subscription completed')
  }

  private async getReportFixes(
    fixReportId: string
  ): Promise<GetMcpFixesQuery['fix']> {
    if (!this.gqlClient) {
      throw new GqlClientError()
    }

    const fixes = await this.gqlClient.getReportFixes(fixReportId)
    logInfo('Fixes retrieved', { fixCount: fixes.length })
    return fixes
  }
}
