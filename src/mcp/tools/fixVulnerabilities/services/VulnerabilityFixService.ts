import {
  Fix_Report_State_Enum,
  GetMcpFixesQuery,
  Scan_Source_Enum,
  SubmitVulnerabilityReportMutationVariables,
  type UploadS3BucketInfoMutation,
} from '../../../../features/analysis/scm/generates/client_generates'
import { logError, logInfo } from '../../../Logger'
import { FilePackingService } from '../../../services/FilePackingService'
import { FileUploadService } from '../../../services/FileUploadService'
import { fixesPrompt } from '../helpers/LLMResponsePrompts'
import { McpGQLClient } from '../helpers/McpGQLClient'

export const VUL_REPORT_DIGEST_TIMEOUT_MS = 1000 * 60 * 5 // 5 minutes in msec

export class VulnerabilityFixService {
  private gqlClient?: McpGQLClient
  private filePackingService: FilePackingService
  private fileUploadService: FileUploadService

  constructor() {
    this.filePackingService = new FilePackingService()
    this.fileUploadService = new FileUploadService()
  }

  public async processVulnerabilities(
    fileList: string[],
    repositoryPath: string
  ): Promise<string> {
    try {
      this.validateFiles(fileList)
      const apiKey = this.validateApiKey()
      this.gqlClient = await this.initializeGqlClient(apiKey)

      const repoUploadInfo = await this.initializeReport()
      const zipBuffer = await this.packFiles(fileList, repositoryPath)
      await this.uploadFiles(zipBuffer, repoUploadInfo)

      const projectId = await this.getProjectId()
      await this.runScan({
        fixReportId: repoUploadInfo!.fixReportId,
        projectId,
      })

      const fixes = await this.getReportFixes(repoUploadInfo!.fixReportId)
      return fixesPrompt(fixes)
    } catch (error) {
      const message = (error as Error).message
      logError('Vulnerability processing failed', { error: message })
      throw error
    }
  }

  private validateFiles(fileList: string[]): void {
    if (fileList.length === 0) {
      throw new Error('No files to fix')
    }
  }

  private validateApiKey(): string {
    const apiKey = process.env['API_KEY']
    if (!apiKey) {
      throw new Error('API_KEY environment variable is not set')
    }
    return apiKey
  }

  private async initializeGqlClient(apiKey: string): Promise<McpGQLClient> {
    const gqlClient = new McpGQLClient({
      apiKey,
      type: 'apiKey',
    })

    const isConnected = await gqlClient.verifyConnection()
    if (!isConnected) {
      throw new Error('Failed to connect to the API. Please check your API_KEY')
    }

    return gqlClient
  }

  private async initializeReport(): Promise<
    UploadS3BucketInfoMutation['uploadS3BucketInfo']['repoUploadInfo']
  > {
    if (!this.gqlClient) {
      throw new Error('GraphQL client not initialized')
    }

    try {
      const {
        uploadS3BucketInfo: { repoUploadInfo },
      } = await this.gqlClient.uploadS3BucketInfo()
      logInfo('Upload info retrieved', { uploadKey: repoUploadInfo?.uploadKey })
      return repoUploadInfo
    } catch (error) {
      const message = (error as Error).message
      throw new Error(`Error initializing report: ${message}`)
    }
  }

  private async packFiles(
    fileList: string[],
    repositoryPath: string
  ): Promise<Buffer> {
    try {
      const zipBuffer = await this.filePackingService.packFiles(
        repositoryPath,
        fileList
      )
      logInfo('Files packed successfully', { fileCount: fileList.length })
      return zipBuffer
    } catch (error) {
      const message = (error as Error).message
      throw new Error(`Error packing files: ${message}`)
    }
  }

  private async uploadFiles(
    zipBuffer: Buffer,
    repoUploadInfo: UploadS3BucketInfoMutation['uploadS3BucketInfo']['repoUploadInfo']
  ): Promise<void> {
    if (!repoUploadInfo) {
      throw new Error('Upload info is required')
    }

    try {
      await this.fileUploadService.uploadFile({
        file: zipBuffer,
        url: repoUploadInfo.url,
        uploadFields: JSON.parse(repoUploadInfo.uploadFieldsJSON) as Record<
          string,
          string
        >,
        uploadKey: repoUploadInfo.uploadKey,
      })
      logInfo('File uploaded successfully')
    } catch (error) {
      logError('File upload failed', { error: (error as Error).message })
      throw new Error(`Failed to upload the file: ${(error as Error).message}`)
    }
  }

  private async getProjectId(): Promise<string> {
    if (!this.gqlClient) {
      throw new Error('GraphQL client not initialized')
    }

    const projectId = await this.gqlClient.getProjectId()
    logInfo('Project ID retrieved', { projectId })
    return projectId
  }

  private async runScan(params: {
    fixReportId: string
    projectId: string
  }): Promise<void> {
    if (!this.gqlClient) {
      throw new Error('GraphQL client not initialized')
    }

    const { fixReportId, projectId } = params
    logInfo('Starting scan', { fixReportId, projectId })

    const submitVulnerabilityReportVariables: SubmitVulnerabilityReportMutationVariables =
      {
        fixReportId,
        projectId,
        repoUrl: '',
        reference: 'no-branch',
        scanSource: Scan_Source_Enum.Cli,
      }

    logInfo('Submitting vulnerability report')
    const submitRes = await this.gqlClient.submitVulnerabilityReport(
      submitVulnerabilityReportVariables
    )

    if (
      submitRes.submitVulnerabilityReport.__typename !== 'VulnerabilityReport'
    ) {
      logError('Vulnerability report submission failed', {
        response: submitRes,
      })
      throw new Error('🕵️‍♂️ Mobb analysis failed')
    }

    logInfo('Vulnerability report submitted successfully', {
      analysisId: submitRes.submitVulnerabilityReport.fixReportId,
    })

    logInfo('Starting analysis subscription')
    await this.gqlClient.subscribeToGetAnalysis({
      subscribeToAnalysisParams: {
        analysisId: submitRes.submitVulnerabilityReport.fixReportId,
      },
      callback: () => {
        /* empty */
      },
      callbackStates: [Fix_Report_State_Enum.Finished],
      timeoutInMs: VUL_REPORT_DIGEST_TIMEOUT_MS,
    })

    logInfo('Analysis subscription completed')
  }

  private async getReportFixes(
    fixReportId: string
  ): Promise<GetMcpFixesQuery['fix']> {
    if (!this.gqlClient) {
      throw new Error('GraphQL client not initialized')
    }

    const fixes = await this.gqlClient.getReportFixes(fixReportId)
    logInfo('Fixes retrieved', { fixCount: fixes.length })
    return fixes
  }
}
