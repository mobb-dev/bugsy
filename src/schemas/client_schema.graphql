query Me {
  me {
    id
    email
    userOrganizationsAndUserOrganizationRoles {
      organization {
        brokerHosts {
          realDomain
          virtualDomain
        }
      }
    }
    scmConfigs {
      id
      orgId
      refreshToken
      scmType
      scmUrl
      scmUsername
      token
      tokenLastUpdate
      userId
      scmOrg
      isTokenAvailable
    }
  }
}

query getLastOrgAndNamedProject($email: String!, $projectName: String!) {
  user(where: { email: { _eq: $email } }) {
    id
    userOrganizationsAndUserOrganizationRoles(order_by: { createdOn: desc }) {
      id
      organization {
        id
        projects(where: { name: { _eq: $projectName } }) {
          name
          id
        }
      }
    }
  }
}

query getLastOrg($email: String!) {
  user(where: { email: { _eq: $email } }, limit: 1) {
    id
    name
    userOrganizationsAndUserOrganizationRoles(order_by: { createdOn: desc }) {
      id
      organization {
        id
      }
    }
  }
}

query GetEncryptedApiToken($loginId: uuid!) {
  cli_login_by_pk(id: $loginId) {
    encryptedApiToken
  }
}

query FixReportState($id: uuid!) {
  fixReport_by_pk(id: $id) {
    state
  }
}

query GetVulnerabilityReportPaths($vulnerabilityReportId: uuid!) {
  vulnerability_report_path(
    where: { vulnerabilityReportId: { _eq: $vulnerabilityReportId } }
  ) {
    path
  }
}

subscription getAnalysisSubscription($analysisId: uuid!) {
  analysis: fixReport_by_pk(id: $analysisId) {
    id
    state
    failReason
  }
}

query getAnalysis($analysisId: uuid!) {
  analysis: fixReport_by_pk(id: $analysisId) {
    id
    state
    failReason
    repo {
      commitSha
      pullRequest
    }
    vulnerabilityReportId
    vulnerabilityReport {
      projectId
      project {
        organizationId
        organization {
          ghFixerNoFixComments
        }
      }
      file {
        signedFile {
          url
        }
      }
    }
  }
}

query getFixes($filters: fix_bool_exp!) {
  fixes: fix(where: $filters) {
    safeIssueType
    id
    severityText
    safeIssueLanguage
    patchAndQuestions {
      __typename
      ... on FixData {
        patch
        patchOriginalEncodingBase64
        questions {
          defaultValue
          extraContext {
            key
            value
          }
          index
          inputType
          key
          name
          options
          value
          __typename
        }
        extraContext {
          extraContext {
            key
            value
            __typename
          }
          fixDescription
          manifestActionsRequired {
            action
            lib {
              name
              version
            }
            language
            typesLib {
              envName
              name
              version
            }
            __typename
          }
          __typename
        }
      }
    }
  }
}

query getVulByNodesMetadata(
  $filters: [vulnerability_report_issue_code_node_bool_exp!]
  $vulnerabilityReportId: uuid!
) {
  vulnerabilityReportIssueCodeNodes: vulnerability_report_issue_code_node(
    order_by: { index: desc }
    where: {
      _or: $filters
      vulnerabilityReportIssue: {
        fixId: { _is_null: false }
        vulnerabilityReportId: { _eq: $vulnerabilityReportId }
      }
    }
  ) {
    vulnerabilityReportIssueId
    path
    startLine
    vulnerabilityReportIssue {
      safeIssueType
      fixId
      category
      vulnerabilityReportIssueTags {
        tag: vulnerability_report_issue_tag_value
      }
    }
  }
  fixablePrVuls: vulnerability_report_issue_aggregate(
    where: {
      fixId: { _is_null: false }
      vulnerabilityReportId: { _eq: $vulnerabilityReportId }
      codeNodes: { _or: $filters }
    }
  ) {
    aggregate {
      count
    }
  }
  nonFixablePrVuls: vulnerability_report_issue_aggregate(
    where: {
      fixId: { _is_null: true }
      vulnerabilityReportId: { _eq: $vulnerabilityReportId }
      codeNodes: { _or: $filters }
    }
  ) {
    aggregate {
      count
    }
  }
  totalScanVulnerabilities: vulnerability_report_issue_aggregate(
    where: { vulnerabilityReportId: { _eq: $vulnerabilityReportId } }
  ) {
    aggregate {
      count
    }
  }
  irrelevantVulnerabilityReportIssue: vulnerability_report(
    where: { id: { _eq: $vulnerabilityReportId } }
  ) {
    vulnerabilityReportIssues(
      where: {
        fixId: { _is_null: true }
        category: { _in: [Irrelevant, FalsePositive, Filtered] }
        _not: {
          vulnerabilityReportIssueTags: {
            vulnerability_report_issue_tag_value: { _eq: SUPPRESSED }
          }
        }
      }
    ) {
      id
      safeIssueType
      fixId
      category
      vulnerabilityReportIssueTags {
        tag: vulnerability_report_issue_tag_value
      }
      codeNodes(order_by: { index: desc }, where: { _or: $filters }, limit: 1) {
        path
        startLine
      }
      fpId
    }
  }
}

query getFalsePositive($fpId: uuid!) {
  getFalsePositive(fpId: $fpId) {
    ... on FalsePositiveData {
      extraContext {
        key
        value
      }
      fixDescription
    }
  }
}

mutation updateScmToken(
  $scmType: String!
  $url: String!
  $token: String!
  $org: String
  $refreshToken: String
) {
  updateScmToken(
    scmType: $scmType
    url: $url
    token: $token
    org: $org
    refreshToken: $refreshToken
  ) {
    __typename
    ... on ScmAccessTokenUpdateSuccess {
      token
    }
    ... on InvalidScmTypeError {
      status
      error
    }
    ... on BadScmCredentials {
      status
      error
    }
    ... on RepoUnreachableError {
      status
    }
  }
}

mutation uploadS3BucketInfo($fileName: String!) {
  uploadS3BucketInfo(fileName: $fileName) {
    status
    error
    reportUploadInfo: uploadInfo {
      url
      fixReportId
      uploadFieldsJSON
      uploadKey
    }
    repoUploadInfo {
      url
      fixReportId
      uploadFieldsJSON
      uploadKey
    }
  }
}

# AI Blame uploads (remote schema: aiBlameApi via Hasura)

scalar Timestamp

input AIBlameInferenceInitInput {
  promptFileName: String!
  inferenceFileName: String!
  aiResponseAt: Timestamp!
  model: String
  toolName: String
  metadataJSON: String
  computerName: String
  userName: String
}

input AIBlameInferenceFinalizeInput {
  aiBlameInferenceId: String!
  promptKey: String!
  inferenceKey: String!
  aiResponseAt: Timestamp!
  model: String
  toolName: String
  metadataJSON: String
  computerName: String
  userName: String
}

input ParentCommitInput {
  sha: String!
  timestamp: Timestamp!
}

mutation GetTracyDiffUploadUrl($commitSha: String!) {
  getTracyDiffUploadUrl(commitSha: $commitSha) {
    status
    error
    uploadInfo {
      url
      uploadFieldsJSON
      uploadKey
    }
  }
}

mutation AnalyzeCommitForExtensionAIBlame(
  $repositoryURL: String!
  $commitSha: String!
  $organizationId: String!
  $commitTimestamp: Timestamp
  $parentCommits: [ParentCommitInput!]
) {
  analyzeCommitForAIBlame(
    repositoryURL: $repositoryURL
    commitSha: $commitSha
    organizationId: $organizationId
    commitTimestamp: $commitTimestamp
    parentCommits: $parentCommits
  ) {
    __typename
    ... on ProcessAIBlameFinalResult {
      status
      inferencesProcessed
      attributionsCreated
      attributions {
        id
        aiBlameCommitId
        aiBlameInferenceId
        filePath
        lineNumber
        model
        toolName
        commitSha
        inferenceType
      }
    }
    ... on ProcessAIBlameErrorResult {
      status
      error
    }
    ... on ProcessAIBlameRequestedResult {
      status
      requestIds
    }
  }
}

query GetAIBlameInference($aiBlameInferenceIds: [uuid!]) {
  ai_blame_inference(where: { id: { _in: $aiBlameInferenceIds } }) {
    id
    type
    aiResponseAt
  }
}

query GetAIBlameAttributionPrompt($aiBlameAttributionId: String!) {
  getAIBlameInferenceData(aiBlameAttributionId: $aiBlameAttributionId) {
    promptUrl
  }
}

query GetPromptSummary($aiBlameAttributionId: String!) {
  getPromptSummary(aiBlameAttributionId: $aiBlameAttributionId) {
    __typename
    ... on PromptSummarySuccess {
      status
      summary {
        goal
        developersPlan
        aiImplementationDetails
        importantInstructionsAndPushbacks
        frictionScore {
          score
          justification
        }
      }
    }
    ... on PromptSummaryError {
      status
      error
    }
  }
}

mutation UploadAIBlameInferencesInit($sessions: [AIBlameInferenceInitInput!]!) {
  uploadAIBlameInferencesInit(sessions: $sessions) {
    status
    error
    uploadSessions {
      aiBlameInferenceId
      prompt {
        url
        artifactId
        fileName
        uploadFieldsJSON
        uploadKey
      }
      inference {
        url
        artifactId
        fileName
        uploadFieldsJSON
        uploadKey
      }
    }
  }
}

mutation FinalizeAIBlameInferencesUpload(
  $sessions: [AIBlameInferenceFinalizeInput!]!
) {
  finalizeAIBlameInferencesUpload(sessions: $sessions) {
    status
    error
  }
}

mutation DigestVulnerabilityReport(
  $vulnerabilityReportFileName: String
  $fixReportId: String!
  $projectId: String!
  $scanSource: String!
  $repoUrl: String
  $reference: String
  $sha: String
) {
  digestVulnerabilityReport(
    fixReportId: $fixReportId
    vulnerabilityReportFileName: $vulnerabilityReportFileName
    projectId: $projectId
    scanSource: $scanSource
    repoUrl: $repoUrl
    reference: $reference
    sha: $sha
  ) {
    __typename
    ... on VulnerabilityReport {
      vulnerabilityReportId
      fixReportId
    }
    ... on RabbitSendError {
      status
      error
    }
    ... on ReportValidationError {
      status
      error
    }
    ... on ReferenceNotFoundError {
      status
      error
    }
  }
}

mutation SubmitVulnerabilityReport(
  $fixReportId: String!
  $repoUrl: String!
  $reference: String!
  $projectId: String!
  $scanSource: String!
  $sha: String
  $experimentalEnabled: Boolean
  $vulnerabilityReportFileName: String
  $pullRequest: Int
  $isFullScan: Boolean
  $scanContext: String!
  $fileCount: Int
) {
  submitVulnerabilityReport(
    fixReportId: $fixReportId
    repoUrl: $repoUrl
    reference: $reference
    sha: $sha
    experimentalEnabled: $experimentalEnabled
    pullRequest: $pullRequest
    isFullScan: $isFullScan
    projectId: $projectId
    vulnerabilityReportFileName: $vulnerabilityReportFileName
    scanSource: $scanSource
    scanContext: $scanContext
    fileCount: $fileCount
  ) {
    __typename
    ... on VulnerabilityReport {
      vulnerabilityReportId
      fixReportId
    }
  }
}

mutation CreateCommunityUser {
  initOrganizationAndProject {
    __typename
    ... on InitOrganizationAndProjectGoodResponse {
      projectId
      userId
      organizationId
    }
    ... on UserAlreadyInProjectError {
      error
      status
    }
    ... on UserHasNoPermissionInProjectError {
      error
      status
    }
  }
}

mutation CreateCliLogin($publicKey: String!) {
  insert_cli_login_one(object: { publicKey: $publicKey }) {
    id
  }
}

mutation performCliLogin($loginId: String!) {
  performCliLogin(loginId: $loginId) {
    status
  }
}

mutation CreateProject($organizationId: String!, $projectName: String!) {
  createProject(organizationId: $organizationId, projectName: $projectName) {
    projectId
  }
}

query validateRepoUrl($repoUrl: String!) {
  validateRepoUrl(repoUrl: $repoUrl) {
    __typename
    ... on RepoValidationSuccess {
      status
      defaultBranch
      defaultBranchLastModified
      defaultBranchSha
      scmType
    }
    ... on RepoUnreachableError {
      status
      error
      scmType
    }
    ... on BadScmCredentials {
      status
      error
      scmType
    }
  }
}

query gitReference($repoUrl: String!, $reference: String!) {
  gitReference(repoUrl: $repoUrl, reference: $reference) {
    __typename
    ... on GitReferenceData {
      status
      sha
      date
    }
    ... on ReferenceNotFoundError {
      status
      error
    }
  }
}

mutation autoPrAnalysis(
  $analysisId: String!
  $commitDirectly: Boolean
  $prId: Int
  $prStrategy: PRStrategy
) {
  autoPrAnalysis(
    analysisId: $analysisId
    sameBranchCommit: $commitDirectly
    prId: $prId
    prStrategy: $prStrategy
  ) {
    __typename
    ... on AutoPrSuccess {
      status
      appliedAutoPrIssueTypes
    }
    ... on AutoPrError {
      status
      error
    }
  }
}

fragment FixDetails on fix {
  id
  confidence
  safeIssueType
  severityText
  gitBlameLogin
  severityValue
  vulnerabilityReportIssues {
    category
    parsedIssueType
    parsedSeverity
    vulnerabilityReportIssueTags {
      vulnerability_report_issue_tag_value
    }
  }
  sharedState {
    id
    downloadedBy {
      downloadSource
    }
  }
  patchAndQuestions {
    __typename
    ... on FixData {
      patch
      patchOriginalEncodingBase64
      extraContext {
        extraContext {
          key
          value
        }
        fixDescription
      }
    }
  }
}

fragment FixReportSummaryFields on fixReport {
  id
  createdOn
  repo {
    originalUrl
  }
  issueTypes
  CRITICAL: fixes_aggregate(
    where: {
      _and: [
        { vulnerabilityReportIssues: { category: { _eq: Fixable } } }
        { severityText: { _eq: "critical" } }
      ]
    }
  ) {
    aggregate {
      count
    }
  }
  HIGH: fixes_aggregate(
    where: {
      _and: [
        { vulnerabilityReportIssues: { category: { _eq: Fixable } } }
        { severityText: { _eq: "high" } }
      ]
    }
  ) {
    aggregate {
      count
    }
  }
  MEDIUM: fixes_aggregate(
    where: {
      _and: [
        { vulnerabilityReportIssues: { category: { _eq: Fixable } } }
        { severityText: { _eq: "medium" } }
      ]
    }
  ) {
    aggregate {
      count
    }
  }
  LOW: fixes_aggregate(
    where: {
      _and: [
        { vulnerabilityReportIssues: { category: { _eq: Fixable } } }
        { severityText: { _eq: "low" } }
      ]
    }
  ) {
    aggregate {
      count
    }
  }
  fixes(
    where: {
      _and: [
        { vulnerabilityReportIssues: { category: { _eq: Fixable } } }
        {
          _or: [
            { gitBlameLogin: { _is_null: true } }
            { _not: { gitBlameLogin: { _ilike: $currentUserEmail } } }
          ]
        }
        $filters
      ]
    }
    order_by: { severityValue: desc }
    limit: $limit
    offset: $offset
  ) {
    ...FixDetails
  }
  userFixes: fixes(
    where: {
      _and: [
        { gitBlameLogin: { _ilike: $currentUserEmail } }
        { vulnerabilityReportIssues: { category: { _eq: Fixable } } }
        $filters
      ]
    }
    order_by: { severityValue: desc }
    limit: $limit
    offset: $offset
  ) {
    ...FixDetails
  }

  filteredFixesCount: fixes_aggregate(
    where: {
      _and: [
        { vulnerabilityReportIssues: { category: { _eq: Fixable } } }
        $filters
      ]
    }
  ) {
    aggregate {
      count
    }
  }
  totalFixesCount: fixes_aggregate {
    aggregate {
      count
    }
  }
  vulnerabilityReport {
    scanDate
    vendor
    projectId
    project {
      organizationId
    }
    totalVulnerabilityReportIssuesCount: vulnerabilityReportIssues_aggregate {
      aggregate {
        count
      }
    }
    notFixableVulnerabilityReportIssuesCount: vulnerabilityReportIssues_aggregate(
      where: { category: { _neq: Fixable } }
    ) {
      aggregate {
        count
      }
    }
  }
}

query GetFixReportsByRepoUrl($repoUrl: String!) {
  fixReport(where: { repo: { originalUrl: { _eq: $repoUrl } } }) {
    id
    state
    createdOn
    repo {
      originalUrl
    }
    vulnerabilityReport {
      scanDate
      vendor
    }
  }
}

query GetReportFixes(
  $reportId: uuid!
  $filters: fix_bool_exp = {}
  $limit: Int!
  $offset: Int!
  $currentUserEmail: String!
) {
  fixReport(
    where: { _and: [{ id: { _eq: $reportId } }, { state: { _eq: Finished } }] }
  ) {
    ...FixReportSummaryFields
  }
  expiredReport: fixReport(
    where: { _and: [{ id: { _eq: $reportId } }, { state: { _eq: Expired } }] }
  ) {
    id
    expirationOn
  }
}

query GetLatestReportByRepoUrl(
  $repoUrl: String!
  $filters: fix_bool_exp = {}
  $limit: Int!
  $offset: Int!
  $currentUserEmail: String!
) {
  fixReport(
    where: {
      _and: [
        { repo: { originalUrl: { _eq: $repoUrl } } }
        { state: { _eq: Finished } }
        { vulnerabilityReport: { scanSource: { _neq: MCP } } }
      ]
    }
    order_by: { createdOn: desc }
    limit: 1
  ) {
    ...FixReportSummaryFields
  }
  expiredReport: fixReport(
    where: {
      _and: [
        { repo: { originalUrl: { _eq: $repoUrl } } }
        { state: { _eq: Expired } }
        { vulnerabilityReport: { scanSource: { _neq: MCP } } }
      ]
    }
    order_by: { createdOn: desc }
    limit: 1
  ) {
    id
    expirationOn
  }
}

mutation updateDownloadedFixData(
  $fixIds: [String!]!
  $source: FixDownloadSource!
) {
  updateDownloadedFixData(fixIds: $fixIds, source: $source) {
    status
  }
}

query GetUserMvsAutoFix($userEmail: String!) {
  user_email_notification_settings(
    where: { user: { email: { _eq: $userEmail } } }
  ) {
    mvs_auto_fix
  }
}

subscription streamBlameAiAnalysisRequests($requestIds: [uuid!]!) {
  blame_ai_analysis_request(where: { id: { _in: $requestIds } }) {
    id
    state
    commitId
    organizationId
    createdOn
  }
}

subscription streamCommitBlameRequests($requestIds: [uuid!]!) {
  commit_blame_request(where: { id: { _in: $requestIds } }) {
    id
    state
    organizationId
    repositoryUrl
    commitSha
    createdOn
    completedOn
    error
  }
}
